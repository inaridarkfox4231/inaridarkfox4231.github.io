// やり直し！

// どうでもいいけど：https://creating-homepage.com/archives/5006
// まあそういうことらしいです。何だよスペルチェックって、おせっかいうざ...
// まあそういうことで、これで赤い点線が消えました。めでたしめでたし！まあでもAtom使いやすいので好きです！

// バックヤード更新ログ

// 行列って要するに特定のライティング用のシェーダ使うときのカメラ操作とか
// オブジェクトに回転や平行移動をさせたい場合の簡易オプションみたいな位置づけだから
// それ専用のモジュール用意したらいいわね。どうするかな～そのままパクってもいいんだけど...

// というわけで一通りやったよ～疲れた
// てか視錐台見えないっての。何かしらの方法で可視化しないと厳しいわね。
// いつかね。
// テストするにあたり、パイプラインを...ていうかシェーダーを用意しないと。まあそれは
// グローバルで自前で用意するんだけど。
// だって備え付けても仕方ないでしょいじってなんぼなんだから。中身見えてないと色々めんどくさいし。

// カリングについても突っ込まないといけないんだよなぁ...仕方ないんだけど。あれ苦手。でもやらねばね。

// 20220927
// 一応動いたわ...寝るわ...
// Painter側のsizeとtypeは意図した挙動しないということで廃止
// Figureサイドでsizeを2とか3とか指定したうえでcountで割って...って感じで。よろしくで。
// Figureのtypeが今んとこgl.FLOAT固定だけどそのうち色々使う機会が来る...かもしれない。
// 動的更新は今んとこ実行する方法...まあそのうち用意するつもり。Float32の配列を渡してそれ使って...
// グローバルで...とかいう感じで。
// 行列も含めて検証することが山積み。大変だ～。
// webgl2表記でシェーダー書いたりとか。色々ね。

// 手始めに「createShader」と「shader」、これを移してしまう。
// _glでアクセスできないので...（意外だった）まあ仕方ないわね。setUniformもおいおい移していくけど...（未定）

// setUniform、中でuseProgramしてるのか...分けたいんだよな～
// ていうかこの方法でshader作っちゃうとsetUniformが付与されないわけね。まずいわな。

// キャッシュデータのは多分、同じ内容を毎フレームsetUniformするのが無駄が多いんだと思う。でもなぁ...
// テクスチャとか考えるとそれ別に要らないんじゃ...って思ってしまう（いいけど）
// あとこれで網羅したわけじゃないってのはちょっと気になるかも。

// 中でしか使わない関数(private)は_で始めた方がいいと思う。ちょっと修正が必要かも。

// background(~~~)だっけ
// 単色で塗りつぶすのとか欲しいかも

// 20220927
// clearをunbindに改称（clearは別の意味で使いたいので）
// こっちでしか使わない関数に_を付ける（エクスポートしない関数）

// 20220928
// webgl2ではtexImage2Dでの指定の仕方について、typeがgl.FLOATの場合、ちょっとややこしいようで...
// 具体的には「https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D」のInternalFormatのとこに
// リンクが：「https://registry.khronos.org/webgl/specs/latest/2.0/#TEXTURE_TYPES_FORMATS_FROM_DOM_ELEMENTS_TABLE」
// 張ってあってこの組み合わせじゃないといけない。つまりgl.RGBAーgl.RGBAの場合UNSIGNED_BYTE(0～255)を含む3通りで
// gl.FLOATは対象外！
// webgl1のようにやりたかったら下から2番目の「gl.RGBA32Fーgl.RGBAーgl.FLOAT」にしないといけないのだ。
// ...適宜修正しないとね...

// gl.RGBA32F --- gl.RGBA --- gl.FLOAT
// gl.RGBA16F --- gl.RGBA --- gl.FLOAT
// gl.RGBA16F --- gl.RGBA --- gl.HALF_FLOAT
// gl.RGBA --- gl.RGBA --- gl.UNSIGNED_BYTE
// gl.R32F --- gl.RED --- gl.FLOAT
// gl.RGB32F --- gl.RGB --- gl.FLOAT
// gl.R8 ---- gl.RED ---- gl.UNSIGNED_BYTE

// それ以前に
// https://stackoverflow.com/questions/69016956/webgl2-incomplete-framebuffer
// RGBA32Fは書き込み不可能？？「https://registry.khronos.org/OpenGL/specs/es/3.0/es_spec_3.0.pdf#page=143&zoom=100,168,666」
// renderableではない、ということ。つまり書き込めるテクスチャとして使えないと...で、調べたらtexStorage2Dというのが
// でてきました。こっちを使え...？というかwebgl2においてそもそもtexImage2Dが非推奨なんだそうです。
// 参考：https://ics.media/web3d-maniacs/webgl2_texture2darray/
// でもpavelさんの流体のは普通にtexImage2Dで取得してたし、書き込んでたし。つじつま合わないんですよね...

// pavelさんこれ使ってた：
// https://developer.mozilla.org/en-US/docs/Web/API/EXT_color_buffer_float
// 拡張機能です。gl.getExtension('EXT_color_buffer_float');
// これで使えるようになるとのこと。はぁ...なるほどね...これでcolor-renderableになるわけだ...
// webgl2だから拡張無しでOKかと思ったらそういうわけにはいかないわけだ。

// gl定数の辞書は...リスト作っておいて文字列でアクセスできるようにしましょうね...汎用性考えるとね。
// 辞書作らないとキリがないので。
// 勝手に数字書き換えられても困るのでマジックナンバーは使わない方向で

// usage誤解してたわ：https://developer.mozilla.org/ja/docs/Web/API/WebGLRenderingContext/bufferData
// となると頻繁に更新するならSTREAM_DRAWがいいわけだ...そしてwebgl2なので書き込めないようにできるということ。
// でもめんどくさいのでとりあえず...
// readとcopyは書き込み不可能ということですね。readの場合はメソッドで取り出せるようです。
// copyはそれすらできない、TransformFeedbackでGPU内部の処理で変更することは可能みたい。だからこれを指定すると。
// readはあれ、readPixelsを使うってことなんだろうね。使い方...

// カメラについてなんだけどさ...
// vec3とかクォータニオンとか用意して整理するのはどうよ。で、カメラの3本をグローバルのベクトルにして...
// とかしたら面白そう。よくわかんないけど。vec3はクォータニオンに含ませることができる。そして回転量はクォータニオンで
// あらわせる、のも知ってるし、演算も知ってる。ただ使い道とか細かい部分について理解が足りないというか。それで二の足踏んでる感じ
// なんだけど、他の用途（線形補間によるアニメーション）もあるし、苦手意識をなくしたいのよね。

// 20220930
// Timer実装したいかな。とりあえず最低限、スタートとゴールだけ...
// あとあれ
// 名前で始点を決めて、終点で名前を呼び出して、それに60掛けて1000で割った値を出すとか。いわゆる「fpsタイマー」みたいな
// 使い方ができるといいね。ていうか要らないか。単純に差を取るだけでいいや。setとgetでいいや。便利！
// hsv2rgbもだけど、他のプログラムでも使える関数充実させたいわね。

// 今日考えたこと
// トランスフォームフィードバックってバーテックスシェーダだけでいいのでは...？
// ただジオメトリシェーダがないからな...（片手落ち）。その関係で必須なのかもしれない、まだ触ってないからわからん。
// p5.Textureの中身が知りたい。あそこをブラックボックスにしておくのは気持ち悪いからな。頻繁にお世話になってるし。
// save関数でpixelDensityに左右されてしまう問題がいい加減うざいので何とかしたい。そもそもsaveって何やってるの？？
// _glで生成してるRenderNodeだけど_gl使ってなくない？？？まあでもp5.Texture由来のテクスチャを使おうってなったら
// _glも使う羽目になるのかな...極力使いたくないので複雑だわね。
// 雲はいいよ。そのうちUnityかなんかで作る方法探すから。他にやること山ほどあるでしょ。
// さしあたりvbaかなぁ...でも後回しでもいいかなぁ。


// 勉強もかねててつのりさんのリアルタイム~~~をやるのもありかな
// あ、fbmだけどマルチパスでフレームバッファで計算したら負荷が軽くなるかもしれないって思いついた
// あとあれビットシフトランダムやってみたいね。

// 20221002
// 今見たけど「_gl」使ってないですね...一切。ということはglだけでいいということ...
// テクスチャですよね。これを_glを使わないで生成できるようにしましょう。で、登録して呼び出せるようにする。
// マルチテクスチャの実験もする。これで完全に_glと切り離せる。...ということは。。。
// まあ、何とかしましょう。

// _glをglに。_gl使ってないので。廃止。

// 20221003
// precision宣言ですが、バーテックスシェーダは無条件でhighpなので不要とのこと。
// fragについてはノイズなど一部の高い精度が求められる計算の場合にhighpにしないとスマホの方でおかしな挙動になる
// 可能性があるとのことです。ただ富士山に雪降らせるやつはlightFragでhighpしたらおかしくなったんですよ...
// だからさじ加減が求められるとのことです。はい。了解！GPGPU計算とかもhighpのが良さそう。
// ただレイマはそれでも重いんですよね...レンダリングにはかろうじて成功するんですけど、重いです。
// ディファード？で、たとえば法線とか色とか複数のフレームバッファにMRTで書きだして、
// それ使って描画すると速い、可能性がある、とのことです...もしくは深度とか。んー...

// そうよねレイマのライティングは...あーでもあれ、計算？のとこだけhighpが求められる、とかかな...わかんない！

// 20221003
// 地味に更新。辞書にr32fとr16fとredを追加しました。これでR32Fフォーマットのテクスチャが使えるようになりました。
// それはいいけどdrawingBufferWidthとHeight取得する関数とテクスチャ作る関数早く実装してちょ！（はいはい）
// 作りました（getDrawingBufferSizeです。。。まんまです。）
// で、textureはそのうち何とかしますね...copyのvertとfragどうしようね。

// 20221005
// enable, disable, cullFaceあたりでinvalidな名前指定の際にエラーが発生するように仕様変更。
// 問題なく素通りしちゃってたので...困るねこういうの。困るほんとに。

// 重要な変更。法線計算の関数が時計回り前提になってました（p5jsがBACKでデフォルトのポリゴンを描画してて、
// それに倣う形でやってたので）。なので逆にしました。これで反時計回りの頂点指定で法線がきちんと計算されます。
// 今んとこあんまポリゴン系手を出してないので。早めに気付けてよかったです...

// MRT難しくなさそう：https://wgld.org/d/webgl2/w011.html そのうちやってみる！

// 20221005
// 重要な仕様変更：clearなんですが、DEPTH_BUFFERをクリアする、ようにしました。
// えーとね。観察力不足。
// clearDepthの既定値は1です。なので全部1になるわけですね。

// そういえばframebufferのdepth要らない場合は用意しないようにしようとかあったっけ...まあいいや。
// そのうちh_doxasさんのサンプルやるようになったらいろいろ出てくるでしょう...色々ね。

// 20221006
// jsDocですか。なるほど...https://ics.media/entry/6789/
// ライブラリ大きくなってきたしなんか注釈あると便利かもね。

// CameraExをちょっといじってレイマーチングなどに役立つ情報取得の関数を追加

// 20221006
// いろいろおかしい...orthoが機能してない、まともに。
// あとy軸を上方向にしたいのです。テストコード書くよ。
// orthoの行列が転置になってたバグを修正しました。ついでにleft,right,bottom,topのデフォルト値設定。
// それから注釈も。さてと。
// upside down.
// これにより、頂点のインデックスの振り方も逆になります。ひえ。。一旦作りかけのメッシュ関数を排除。あれも、
// きちんと作りたいんだけど今ちょっと暇がないのです。
// y軸上にした関係で法線の計算関数の順番も元に戻すことになりました。なんじゃい...
// そうなんですよね。反時計回りでかつy軸反転だから(-1)^2=1の理屈で元に戻っちゃったんです。なんだかな...

// 正規化デバイスと同じ理屈で頂点を並べていくので板ポリ芸関連は影響ないです、というか射影行列使ってないんだから
// 影響あるわけがない。あったら事件だわ。

// まあy軸逆にしただけなんで、何がどうってことも無いけど。ただね。
// たとえばz軸手前x軸右っていうレイマのテンプレ考えたときにy軸が下向いてたら「はぁ？？」ってなるやん。そういうこと。

// 20221008
// カメラ仕様変更案
// eyeとか個別にいじれるように。あとxだけとかyだけとかでいじれるように。
// で、行列を計算する部分を別に呼び出す感じに。んでperseかortho化に応じて射影行列が計算される仕様...とか。
// farとnearをMAX_DISTとかに当てはめるのも楽しそう。レイマーチング、orthoでもいいと思うから。ねぇ？
// orthoのレイマーチング普通にありだと思うんだけど何であんま見掛けないんだろ...

// typo（setPersepective → setPerspective）

// カメラがcenterの方向を向いてくれない...どうして...
// 本家で確認した。カメラおかしい！！！おかしい！おかしいな...centerちゃんと0,0,0になってるのに...
// どうもcenterが一緒に移動しちゃってるみたいなのよ。というか機能してない？？？

// ...本家の方がカメラの設定してからtransformしてたからそれに倣ったら解消した、
// そもそもきちんと計算したら明らかだったわ。馬鹿ですね...
// 加えて行列のメソッドとしてtranslateやrotateX, rotateYを実装してtransformの方はそこからいただいたメソッドで
// 変換するように修正しました。おつかれ！！

// ...eyeの取得を行列からやってたんですが、あそこeyeの座標値じゃねぇよ！！！間違えた！ので、直しました。

// カメラ移動メソッド2つ追加します
// 一つ目...えーと。upとtopを使って縦方向に移動する感じのメソッド。

// upって更新する必要あるんだろうか。うーん...マウス移動であちこちできるようにしたいなと。
// 周回はいいとして...
// up更新しても特に問題ないよね。更新しちゃうかー。
// それかsphereCameraっていうクラスを用意するといいかもしれない。角度の範囲を制限する。
// それか、upベクトルが更新されないことを使って...視点から中心に向かうベクトルがupとの内積、が-1に近づくのを防ぐなど。
// -0.999より小さくなるようなら動かさない、みたいな。そういう意味でもupは動かさない方が良さげ。
// 周回は簡単、topとsideでちょこっと計算するだけ。ズームも簡単。
// upベクトルと視点から中心へのベクトルの内積の絶対値が0.999を越えない、でよさそうね。
// upを動かさないことでそこら辺がうまく働く、っていうのはいいかもしれないね。本家の方も計算後にupはいじってないっぽい。

// zoomは近づく。マイナスで離れる。slideは対象を見据えつつ横移動。ariseはカメラが上下に移動する感じで。
// ただしcenterはいじらないので対象との距離は変化するわね。
// テストはまた今度

// それとは別に今日考えたこと。魚眼レンズ的効果。
// レイマーチングならそれっぽくごまかせるけどラスタライズの場合直線で補間されるので無駄。
// 考えたのは球面への射影
// eye位置から半球面を想像し
// それを縦に切る大円でアスペクト比とかと相性いいのを選んで
// ピクセルからスタートして球面の方に真っ直ぐ進む、んで視点に向かう、その時の線とキャンバスの交点で、
// 色を採取。だからcenterから外に向かうほど膨張する感じ...
// これをレンダリング結果に用いるだけ。

// 20221009
// というわけでfoldRotate計画頓挫です
// これでよかった。影とか色々やりたいし。ディファードレンダリングも中途半端だからMRT使って完成させたい。
// あんなのにこだわってたら何にもできない。
// ノイズとかそういうのを参考にしよう。多面体はもうええわ。鏡映しか勝たんし、ポリゴンしか勝たん。ポリゴン無敵。ポリゴン最強。
// レイマは鏡合わせ一択。rotateなんぞ知るか。ばーか！
// それはさておき

// カメラについて。ariseだけど、角度でいいと思う。で、やり方としては、外積。topベクトルとupの正規化の外積とsideを使って
// 作った三重積がたとえば0.001より小さくなるようなら動かせない、みたいにするといいと思う。その方がいいだろー
// 以上
// orbit見たらupベクトルを固定するポンコツ仕様だった、まあ参考にできるとこだけ参考にするわ。ほんとp5.jsって（（
// upベクトル揺らしたりとかするの楽しいのに。でもまあorbitでやることじゃないな。まあいいや。さてと。
// そうでなくて任意のupベクトルに対してやりたいって話よ。

// ごめんなさいp5jsの悪口みたいになっちゃった。あーあ。

// とりあえずカメラのテストします。

// なんか知らないけどnearとfarが死んでる...？？？

// 背景のせいでした...depth_testをoffにしてからonにする。これでOK!
// そのうちあれもリメイクしたいね...

// 2022/10/10
// カメラテストOKだけどまだまだです。これからローリングとか、デフォルトUPベクトルをいじる操作をしたいのと、
// そのうえでさっきみたいな動作をして大丈夫かどうかのテストをね...大変だね...

// それからorthoのテストと、あとVec3実装したからそれ使って書き換えるのをやらねば...ていうか
// 法線取得のところもVec3で書き換えたいのだ...

// それ終わったらさっさとH3済ませてバンプとかそっち行こう

// カメラ何を実装するにも...あとマウスでいじるならタッチとそれぞれ同じ挙動にしたいのと
// いい加減一通り設定するのめんどくさいからテンプレート作りましょうか。ライティング。デフォルトメッシュ。やること盛りだくさん。わぁ...
// upX,upY,upZはupベクトルとは別の概念で、これが基準となってカメラの上昇の限界が決まるわけ。
// そこら辺上手く実装してもいいんだけどどうしようかね（ゼロ割を回避したい）。ちょっと思いつかない。通り過ぎても大丈夫なのは確認済み。
// ていうか通り過ぎたら逆になる？のか...んー。まああれ、upをちょっとずらして...っていう？
// だからずらすときに、...内積を取って、ゼロになるようなら足す前のベクトルとupベクトルから適切なベクトルを計算して
// 視点はそこにとどまるようにすればいい。そういうやり方もある。

// 実験で分かると思うけど通り過ぎてるのよ、これいいんだけど、限界前で止まる方が、たとえば姿勢制御とか書く場合にはいいかも。
// よろしくね！

// upをさぁ、名前変えるのと、定義時に正規化...やっぱベクトルで書くべき？
// 頭の向きという意味でheadとかいいと思う。axisでもよさそう。基本軸。axisは上を決めるベクトルで...
// ていうかこれがupか。あ、そうか。えーと...どっちもupにふさわしいからな...
// もういっそカメラの方はlocX,locY,locZで...sideと...side廃止？

// つまり画面の上方向という意味でのupと体の軸を決めるupとが競合しちゃってて、という状況
// あとtopってやってるとこ意味的にはfrontの方がいいかも。そうか。で、あっちをtopにすればいいんだ、
// 中心を中心に視点を回転させるときの限界を決めるという意味でもtopがふさわしいわね。

// 結局、「upX,upY,upZのベクトル」→「top」, 今の「top」→「front」で丸く収まりそう。upは保留。画面の上方向という意味で妥当。それでいこう。
// 改名はいいとして、fovやaspectどうしようね。その...保持する意味あるかなって。あるいは、persモード、orthoモード、frustumモード
// それぞれにパラメータ...んー。んー...要らないかなって。定義するとき必要なだけでviewとは別の概念だし。
// つまり、パース行列を定義する際に使われる数値としての扱いでいいかな、と。でもそうなると...いや、問題ない。
// となると今あそこ、ていうかさ。nearとfarってあれ0.1と10で固定じゃん。つまり射影行列は固定で動かさないじゃん。だからそういう風にしても
// 問題ないし、レイマでfovとaspect放り込むのにしても定数使えばいいだけ、カメラから取得する必要ないだろ。

// だからfovとかaspectを保持するのはやめて、定義するようにしましょう。もしくは！！
// これも提案なんだけど。モードオブジェクト。これを用意する。mode={pers:{},ortho:{},frustum:{}}
// んで、それぞれいじれるように。で、モード切替で射影行列が切り替わるように。取得：getProjData("pers")で{fov:~~,aspect:~~}
// setProjMode("pers")とかで再計算される的な...デフォルトはそれぞれ指定に合わせて...
// とかやればいいんだよ！それでいこう。

// モード変数も保持。mode.type = "pers", "ortho", "frustum"
// たとえばzoomはこのあとあの、fovをね...0 < fov < PIの範囲で変化させるんだけど。その方がいいから。で、それはpersの話だから
// persのときしか反応しないようにしたいわけ。frustumはfov関係ないし。
// そんで視点を中心に近づけるのはdollyっていうんだって、だからzoomとdollyという形で分けたい。
// zoomは視点も中心も動かさないでfovだけ動かすんよね。だから若干挙動が違う、近づくのはdollyのin/outにしたい。
// つまりzoomはpersの話だから分ける。orthoは？単純にnear/farをいじればいい（比率だけど）。
// frustumもnear/far...これ使うとあれ、VRChatのカメラみたいなの作れそうで期待してる。

// 2022/10/10
// カメラ仕様変更案まとめ

// 今のeyeXとかcenterXとか、ああいうのをVec3で管理する。upX,upY,upZであらわされるベクトルはtopに改名。
// 今現在のtopは手前という意味でfrontに改名。side,up,frontのローカル軸ベクトルもVec3で管理。
// 射影の概念をビューの概念と切り離す。ビューの仕事はグローバル→ビュー、射影の仕事はビュー→正規化デバイスで役割が異なる。

// ちょっと待って
// そうか...カメラにtransformを名前で登録する...TransformExのクラスを名前で登録して使い回せるように...
// んで一定の場合はいちいちたとえば法線の、nMatrix的な、あれ同じなのに毎フレーム計算してて無駄...モデルとビューの掛け算も
// 毎フレーム計算するのでなければ無駄だわね...静的/動的は分かりやすく分ける！事前に用意するにしてもその方が分かりやすい。
// データを取り出してuniformに登録するプロセスも分かりやすくなる。記述しやすくなる。それで...まあ、そのうち...

// で、射影のモードを、用意。以上。this.proj = {mode:"pers", pers:{~~~}, ortho:{~~~}, frustum:{~~~}}
// this.tf = {tf0:~~~, tf1:~~~, tf2:~~~} this.eye, center, top, side, up, front すべてVec3

// zoomはpersの場合はfovを増減させる...基準が無いのでそうするしかない。nearんとこの矩形をいじる、でもよいのだけどね。
// それでもいいかもな...んー。near*tan(fov/2)になんか足してnearで割ってatanして2倍。
// fovの増減でいいです。残り二つの場合は矩形の重心を中心として拡大する。拡大率...1より大きい値を設定して掛け算。
// もしくは割り算。ていうかね。具体的な数字だとそれを縦横どっちに適用すればいいか分からんでしょ。
// って思ったけどだったらどっちもそれでいいか。どっちもそれでいいか...

// persはそれとは別にfovを具体的に指定できるので問題ないしorthoとfrustumも具体的に指定できるから問題ないねぇ。
// slideとariseはビューの話なので変更なし。nearとfarを倍率で決めるのも変更なし、です。
// ariseはベクトル三重積を用いてtopベクトルを飛び越えないようにする処理が必要です。

// メソッド追加：panは中心を左右にずらす。distanceは変化しない模様。tiltは中心を上下にずらす。これもdistanceが変化しないようですね...
// さらにもともとzoomだったものはdollyとします。これは視点を中心に近づける処理。そういう名前だったのですね...
// また視点と中心の位置関係を保ったまま同時に動かすmoveも定義。
// さらに中心だけ動かすlookAtも移植します。

// 今見たら本家はtopいじってませんね。いじってませんね...
// panとtiltはtopをいじらない（要注意）
// つまりslideとariseの逆バージョンという扱い。まあいいか、それで。で、じゃあtiltは限界を超えないように注意しないとだわね。
// 今見たらtiltはそこら辺の処理サボってますね...ふざけてるな～～～

// upベクトルいじれないとジェットコースターのぐるんぐるんとか表現できないから不便なのでそのうち用意するとして
// 今はいいや

// メッシュについてもメモ。メッシュ。最終的には複数放り込んでくっつけたりできるようにする。個別に用意して。
// UVとか個別に設定したいし。

// グローバルのx,y,zに対してビューと射影組み合わせてスクリーン座標出すやつ欲しいな～とか思ったり。

// lineで線引いたり出来るようになるのはだいぶ先だわね

// CameraEx2をとりあえず構築、テスト待ち。
// 2022/10/11
// defaultが予約語だったので修正。Vec3のおかげですっきりかけました、デバッグ次第だけどな...
// って
// 今更バグなんか怖くねぇんだよなぁ（浮動小数点数バッファのgl_PointSize=1.0で何回ハマったか...）

// Oh!!eyeからcenterを引くつもりが、centerからeyeを引いてたんだね！Oh,My!Oh,My!
// frustumのc8が±逆でInfinityなっててウケる。そりゃ、なるわ。
// とりあえず一通りモード確認した。今日はこのくらいでいいと思う。

// 20221011
// distanceに射影行列が支配されてるのでdistanceを更新するたびに行列の方もいじらないといけないんですが...
// 問題は解決できます。
// Camera2なら簡単。まずdistanceの更新作業の際にそのときのモードの行列を更新する。
// 次にモード変更時にもそのときの距離とモードに応じて行列を更新。これでOK!

// 好きなところにCone配置するとか...そのうち出来るようになるよ...軸とか作りたい。

// frustumのleft,right,bottom,topはdistanceとの比率で指定しないと分かりづらいわね。nearがそうなってる以上、
// これらもそうしないと普通に指定しづらいだろう。

// nearとfarは別メソッドでいじる、そんでclipとか名付けてfrustumの場合はそれに応じて矩形の値を変化させて
// 見た目が変化しないようにすると。

// 関係ないけど_triangulate, あれライブラリの移植ですね。計算もはっきり言って魔窟、似たような実装作るのは無理、つまり、
// あれに関しては_glから有難く頂戴するしかない、そうなると文字メッシュとか分割とかもそうせざるを得ない。諦めて。
// どうしてもというなら元ネタ使う。libtessで調べれば出てくる。ただどう使えばいいかは...どう使うんだろうね...

// もうひとつ。p5.js、webgl部分を叩くのもいいけど、他の部分、知らない機能とかもあるし、あんま馬鹿にすると痛い目見そう。
// 謙虚に。

// 結局、いいものは既にたくさんあるし、それ使いこなせるようになる方が楽で、p5jsで出来ないことは他のツールでできるし、
// p5jsが目的のためにしょぼいことしか出来ないんだったら素直に他のでやればいいわけですから。無意味。そういうことで。
// これ作る努力も結局無意味なんかね。優越感...優越感を味わって心を癒したいだけ...おれはp5jsの駄目な部分を直してやってるんだこいつが
// ポンコツだから、みたいな。叩いてけなして悦に入るのが目的？？そうだったの...？
// 仕事があれで、仕事であれで、自分がクソで、短いコードしか受け入れられなくて、そういうのしか作っちゃ駄目みたいな、コケにされて、
// お前駄目だダメだって、なって。弱い者いじめして。...

// 疲れた

// 結局あれ、頑張ってブルームとかいろいろ、そういうの、でも結局見られるのも反応されるのもつぶプロばっか、
// 違うんだよってなってもなんか、多面体とか、ああいうのも、「誰が作るかが大事～何を作るかじゃなくて～誰が」おれじゃなくて
// そうですか
// TessSky Slice Mt.Fuji snowy ... ... ...
// ねぇ。肥大化した自尊心が
// うぬぼれが
// それで、それで、それで、自分がダメダメで、だめで。はぁ。こういうの作って。それで優越感に浸って、
// もういいです。

// はぁ。だからもうこれは、こういうのはすべて放棄して...

// 20221011
// 仕様変更。モードチェンジ関数は廃止。projの各関数を呼び出すときに自動的に変更
// 仕様変更。frustumモードでnearが変更され矩形の変更が無い場合、見た目が変わらないように矩形を拡縮させる
// 仕様変更。frustumモードで矩形の長さをdistanceに対する比率とする。その方が指定しやすい。
// zoom,spin,arise一応OKなんだけどね。spinで角速度が一定にならない...
// 軸周りの回転実装したらあっさりできた...おつかれ！！

// 20221012
// zoomのfrustumでバグってた。
// モード切替OK

// 球面補間。まずクラス。で、ベクトルを持つ。で、destVectorとcurrentVector.で、
// 移動中は操作できない。で、常に...dest===currentなんだけど、destが変化する、あの、カウンターで。
// 時間制御。updateで足す。足して、一定の値を越えたらそれをチェックしてリセット。
// それと、キャッシュしておいた数値を元に補間、適宜イージング。で、OK.

// 終わる前にメッシュについて簡単に計画だけ立てておく
// 立方体は±1の8つで。スケーリング...

// あの、メッシュ構築時になんか行列をユニフォームで掛けるのであれば、んー...
// たとえば無数に多くのってなった場合uniformは使えず、たとえばidを付与してフレームバッファに落としてそれを参照して変換みたいに
// なるわけですけど（6000個の頂点に対して逐一行列掛けてたら日が暮れてしまう）
// そうでなくてもたとえば1000個の、が40個とか...8000が8つとか...
// だから構築時にtfするのは無しで。で...
// 単純に一律でなんか行列掛けるだけであれば、idを付与したうえでfbに焼いてvsで参照する。

// おわんないよ～

// 確かに一つ一つがたとえ64個くらいだったとしても、それ100とかだったら6400回も行列掛けないとってのはまあ面倒だわね。
// 場合によっては1回とは限らないし...同じものコピーできた方がエコ。というわけで、
// tfについてはそれをフレームバッファに落とす方向で行こう。
// 必要なら3x3,3x3,3x3でcos(t)とsin(t)と1の掛け算の和でさらにuTimeの何倍かをtとするとかで。
// 28. vec4が7つ。で、2800とか。100個別々に動かしたりできるよ。高速で。
// 軸周りの回転でもいいし何でも。平行...あ、そうか...
// 基本的には回転した後で平行移動、ってのがオーソドックスだと思う。だから、
// 3x3,3x3,3x3,1で回転、さらに3で位置。これで4x8に収まる。？？
// 3x3で3,3,3を1,cos,sinの結合...？？
// 3x3,3x3,3x3,1,3x3,1...面倒...4x12でいいと思う。

// そうすればidごとに、違うメッシュの集まりが、フレームバッファの情報を元に、
// 一定の位置まで移動したうえで、もしくは一定の円かなんかの軌道上で、独自の回転運動をするし、
// それをuniformで指定することも無い。つまりドローコール減らせるわけです。そんな感じで。

// 描画の問題はそれでいいとしてメッシュの構築の問題はそれとは別。
// tfについては...だからね。あの、あれ。そういうの全部、cosとsinが一次式である限り、最初にスケール変換したうえで、適当に回転しても、
// そのあと継続的な回転を施しても、それ結局一次式だから。問題ない。だからデフォルトだけ用意しよう。
// 計算はどうせメソッドでやるでしょ

// そういうわけでキューブは-1～1でいいし球もxyz軸ベースで半径1でいい。円柱も高さ±0.5でいいし円錐も高さ±0.5で...
// 台柱は底面半径1で上面が可変になるように（1より小さい）。

// トーラスも比率だけが重要かな...長半径を1で固定しつつ、短半径を0～1と。後はスケールの問題。
// 平面も±1で。これは±1の方がいい...あ、法線？？法線は...
// 平行移動部分で法線は変化しない。それ以外の場合、まず今回スケールに関してはいじらない。定数。そして
// 直交行列の逆は転置。なので直交行列は逆転置の影響を受けず、スケール変換だけが受ける。それも分けておいて...
// 結局今回のように単純な場合、スケール関連の処理だけ考慮すればいいから、法線は中でいじってしまおう。

// モデルが毎回違う...

// webgl2なので普通にモデルビューを作って（ビューはあるのでそれに然るべくモデルをかませるだけ）逆転置でいいや
// 決まった
// 4x12のフォーマットで、上から順に3x3,3x3,3x3で回転、3x3で平行移動。
// その隣に3,3,3でスケール（スケールも時間的な変化を考慮）、最後の3でスケール、回転、平行移動用のテータファクター,
// 合計4x12です。たとえばこれが2000個であれば4x12x2000で96000ですね。多くない（え？）
// 40x50=2000. 4000個ならば80x50で...
// 平行移動オンリーのバージョンも用意するか...
// まあいいか。何でもできるように...
// 欲張ると何にもできないのでまずはこれをやります。

// 曲線データを用意してその上を走る...とか？無理。トーラスノット？？？

// そういうのはいつかで。いいです。今は無理です。

// トーラスノットと正多面体と星形多面体とあとあとあと...

// 20221012
// 原因発覚しました、Math.asinは-1～1の外にある値に対してはNaNを返すんですが、
// ぎりぎり1を越えてしまい、それでNaNになったようです（ほんとにぎりぎり）
// 応急処置として1を越えたら2から引いて-1を下回ったら-2から引くようにしました
// acosを使って工夫するとか、色んな方法があるんだろうけど。変形してatanとか。でも今はこれで許してね。
// 1を越えちゃうのはどうしようもないな...

// 結論
// モデルはこっちで作るかDLするかして、結合するのだけメソッド化して、それを適切に...

// 20221013
// normalをVSで計算することにしたのでgetNormalMatは廃止。あちこち変えないといけないかも。まあ適宜。

TODO
// TODOリスト（覚え書き）
// vba（バーテックスバッファオブジェクト）
// save関数移植（サイズがおかしくならないような...pavelさんのサイトみたいに）
// texture（自前で用意できるように...canvas情報から）
// h_doxasさんのサイトのあれこれ（鏡面反射とかshadowとか）
// ライティング関連の充実、トランスフォーム関連の整備、カメラ2画面の実験、MRTで色付き高速描画
// 簡単なプリミティブの構築（頂点と法線だけでいいです）
// webgl-water（今年の目標はこのレンダリングの流れでこれを再現してOpenProcessingに載せること。いつになるのか...！）

// 歯車メッシュ重いですね。ディファードなら軽くなるのかなぁ。試してみたいな～みたいな～～～みたいな～～～な！
// そのうちね...

// modelに関しては目途が立ったと思う
// 頂点の付け方については反時計回りに...なる。y軸の向きが逆なら反時計回りになる。exportの際にy,zの指定で問題ない。
// こっちは射影行列いじってy軸正にしてあるから問題なく同じように動かせる。それはいいとして...
// 内部データ取得して複製とか。まあでもこれは...頂点数増えたり複雑になるようならインスタンシング...

// 優先順位的にはMRT優先で。モデルはUVの話は切り離す。どうせモデルでいいし。モデルでないと自由にUVとか決められんし。

// 何していいかわからんのでロードマップ作った。漏れてもいいからとりあえず歩き出そう。でないと、終わらん。
// ロードマップ
// まずテクスチャ何とかする
// モデルからのFigure構築
// 閉曲線からメッシュ作る関数の整備...splitとテキストまでは要らないけど。
// マルチ描画とディファード...デプスが消えなければ重ね掛けが利くはず、そのテストね
// MRTの簡単なテスト。まあやらなきゃ始まらんね
// MRTで色付き高速描画
// MRTとマルチ描画で色付き複数オブジェクト高速描画（ここで歯車に応用、って流れだと思う。そういう意味かと。）
// ライティングの充実（スペキュラーだけでも）
// ライティング関連のテンプレートシェーダ（フォワード、ディファード双方）
// 各種ユニフォームセッティングメソッドの整備
// 後回し
// Vertex Buffer Array
// 3Dテクスチャ、環境マッピング、屈折とか光学迷彩などそこら辺。

// 大量描画のパイプライン作る話はどこへ...まあ、いいか...

// ゆくゆくは3Dテクスチャペイント
// そのロードマップについて簡単に説明しておく
// まず通常の描画と同時にMRTでUV値をキャンバスに格納する
// マウスダウンされたらその座標を中心に256x256くらいの範囲で2Dに描画がなされる
// それとは別にpixelDensityを考慮した点の集合があってそれをUVmapのフレームバッファに落とすことでテクスチャの更新を実行する
// 要するに
// テクスチャそれ自身を作り出すわけではなくて...あーでもそうか。たとえばp5で作るにしても画像読み込むにしても
// うんそういうこと
// まずloadImageで画像読み込むだろ
// んでそれを使ってテクスチャを作ってそれとは別にフレームバッファのテクスチャも作る。
// そのテクスチャに読み込んだテクスチャをコピーしオブジェクトの描画時に呼び出してテクスチャペイントとする
// その内容を画像の方を更新することで変えたいんだけど直接2D画像に手を下すことはできない
// というか3Dモデルの方に手を加えてそれがテクスチャ画像に反映されてっていうのを書きたい
// だから3Dの方にUVを貼り付けて範囲内のUVが存在する点に対してUVのところに色を付与、という形を取りたいわけ。以上。

// じゃあまずテクスチャ
// 悪いけど簡単にしたいので入力はp5のグラフィックオンリーでお願い（update前提）
// だから単純にcanvasで取得した結果をtexImage2Dに渡すだけでできる
// updateもしかるべく。
// って思ったけど普通に...でもいいな...
// p5.Imageの場合：canvas要素を取得。
// p5.Graphicsの場合：elt属性を取得
// ImageDataの場合：そのまんま
// という分け方のようで初期化でやることは4つ。ひとつは各種パラメータの管理、次に種類別のpixelsの取得。
// texImage2Dの実行、WRAPとMINMAGの設定。
// メソッドについてはWRAPとMINMAGの切り替え、あとはupdateかなぁ。updateについては2Dのp5のGraphicsが書き換えられることを
// 想定している。
// とはいえ
// さっきのように3Dテクスチャペイントなどは、最初の段階で元のp5ImageだかGraphicsだかはセットした時点で破棄されたも同然であって。
// textureからsaveを発動させる方法を学ばないと、framebuffer経由で更新したテクスチャの保存ができないよね。
// そもそも保存の仕方が分からんのだが...

// まずテクスチャを保存する（元のサイズで）やり方はpavelさんに従うとして、
// 3種類の指定方法についてはそれを別に、んー、まあ、然るべく。

// saveはいいとして。textureについて...やらなきゃ始まらないんだよな。やるべき。やろう。

// 20221016
// MIPMAP用のパラメータを導入。MIPMAPの指定がある場合それを作成する。
// 使う機会があるか分からないけど...テクスチャペイントとかで使えるかも？

// カメラの2を取り上げてさらにタイマーを更新しました...基本的な使い方は一緒です。
// いつかはやらないといけない。今でしょ！！

// Timer更新。カメラの2もなくしました。結論、仕様変更は、大変...！
// test10以降を番号をずらして一旦保留にしました。それどころではないので。

// UInt8ArrayじゃなくてUint8Arrayでした。ごめんなさい。iは小文字でしたね...

// copyShaderは簡単なんですよね。まずVSでuvを取ってvaryingで渡し、FSでセットしたテクスチャを...
// nullであればスクリーンに、nullでなければセットしたframebufferのtextureに、大きさそのままでコピーする。
// つまり縦横ぴっちりぴったりくっつけ！です。

// Textureについてはmemo_textureさんが頑張ってくれてる
// こっちはこっちで別の事をします。
// 遠い未来の目標として。

// CameraとTFをRenderNodeにぶち込んで名前で管理する。
// グローバルを、やめる。
// Timerまでは入れないけど。

// 20221018

// どうでもいいけどclearとclearColor...clearだけでいいよね。なんか、無駄。
// clearで色指定すればいいだけ。

// 今考えてること。
// cameraとtfを統合したWorldクラスを作る
// cameraやtfを適宜返すようにすれば従来通りのchain表記も可能。

// 有効なtfやcameraを文字列で指定しつつメソッドは踏襲で
// 射影やらモデル、モデルビュー、まとめて放り込む関数が欲しい（名前はもう固定でいいし）
// できるわよね
// ついでにライティングクラス「light」も用意しつつ...
// オブジェクト渡すだけで全部やってくれるとかだと嬉しいんだけど
// 複数の
// 様子を見てから

// copyProgramFBO使えばポストエフェクト系めっちゃ簡単に実装できるわ
// ガウスブラーとかブルームとかsobelもlaplacianも自由自在だわね（モノクロも）
// あと_timerんとこdurationTimeとduration混在してるから直しといて：直したよ～～～

// シャドウマッピングむずい。今は無理。

// ピッキングできたけどめんどくさいな。使わなくていいuniformを切るのがめんどくさすぎる、
// MRT無いと実質無理。それと、setUniformのエラーがうざいからなんか出してくれるようにエラー処理よろしくね。
// https://zenn.dev/yukiota/articles/cb53ea21d7cf3994861a
// とか参考になりそう。

// ていうか簡単なテストであっても割とめんどくさいわね...ライティング周り実装急がなきゃ
// 立方体も毎回コピペするの面倒だな...とはいえ慎重にならないとゴミが増えるだけ。そこきちんと考えないといけない。
// あれ。外来種の再導入みたいなやつ。きちんとしないと問題が発生してご破算になるので。

// p5framebufferさん、UNPACK_FLIP_Y_WEBGLのオプション使ってる（問答無用で）
// まあ前提、ポストエフェクト前提ならそういう選択もアリなんかね。
// 今回こういうことがあってそれもアリかなって。
// まあオプションとしてつけとこう。でも普通に使う分には混乱すると思うからデフォルトはfalseでね。
// んなことよりライティングを...

// UNPACKやめよう。めんどくさい。めんどくさいものは採用しません

// さてライティングを...20221019

// まずdiffuseをoutで書く。resultの代わりにdiffuseとspecularにしてoutで書いて、
// それを内部で更新すればいいよ。
// specularの場合、directionalLightに関してもmodelPositionが要るのよね...
// なのでまあ、まあ使わなければいいんですけどね...

// viewDirectionは-modelPositionの正規化
// specularでしか使わないからカットしたんだっけ

// framebufferの各バッファのサイズを、任意指定できるようにした。違う方がいい場合もあるので。
// setUniformのエラーを受け付けるように改良
// エラーはsetUniformで登録したにもかかわらずその値が内部で全く使用されていない場合に起こる
// つまり仮に利用されていなかったとしても（無駄でしかないが）setUniformで送らなければエラーにはならないということ。

// 配列にする準備が整った。さてと。
// あれに倣って5つまで...まあそんなたくさんあっても仕方ないのよ。

// TODO
// 簡単なMRTのテスト
// ピッキングMRT
// 深度可視化MRT
// ディファードMRT
// テクスチャペイントMRT, ただし平面で。立方体、トーラス、ゆくゆくはモデル、objの解析方法などなどetc
// どんどん知っていこう。
// あとTimerのduration機能で遊びたい。以上。シャドウマッピングはまたいつか。

// 理解不足。Program差し替えても同じvboが使えるっぽいですね。
// attributeが中で使われてなくても問題ないそうです。
// これは何がまずいかというと
/*
this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vbo.buf);
// attributeLocationを有効にする
this.gl.enableVertexAttribArray(attr.location);
// attributeLocationを通知し登録する
this.gl.vertexAttribPointer(attr.location, vbo.size, vbo.type, false, 0, 0);
*/

// ここの理解が中途半端なんですよね。
// https://qiita.com/emadurandal/items/5966c8374f03d4de3266 （みんな大好きエマさんのわかりやすいattributeに関する記事）
// この記事で...（ていうかこういう厨二っぽいノリ苦手だからこういう記事あんま読めないっていうか普通に要領よく説明して
// ほしいってつい思ってしまうんだけどまあいいや）

// シェーダーのattribute変数は、GPU上のレジスタと対応付けられる ようです。
// programから問い合わせるが...programとは関係ない？programから問い合わせるのに？？
// gl.enableVertexAttribArrayはgl.useProgramとは何の関係もない ようです。
// locationはprogramから問い合わせるのに？？

// （いくら調べてもスマホだけエラーになる理由が分かりそうにないけれど...まあいいか）

// gl.useProgramでのシェーダープログラムの切り替えにかかわらず、
// gl.enableVertexAttribArrayによるレジスタの有効化、gl.disableVertexAttribArrayによるレジスタの無効化は、
// 効果が持続する のだそうです。ほうほう。uniformと同じで0詰めみたいになってるんかな

// ここuniformみたいに整理して書けるようにしないとねぇ...uniformは完全にprogramのみのお話だから分かりやすいんだけど。
// vboは...attributeは...

// WebGLの実装系によっては、シェーダーで実際に使っていないのに有効化されているレジスタ番号があるとワーニングが出るケースもある

// これですかね。それでdisable?

// gl.vertexAttribPointerを呼ぶ前に、gl.bindBufferの呼び出しによってバインド状態になっていたVBOこそが、
// gl.vertexAttribPointerによって指定されたレジスタへアタッチされる、という仕組みになっている

// それで先にbindする必要があるのか～unbindでnullにしたら効果がなくなると。

// 問題の詳細："pick"のpainterは_loadAttributesでaPositionしか入手できなかったんよ。
// スマホだと。それでエラーになったわけ。

// 調べました～
// _loadAttributesでgl.getProgramParameter(pg, gl.ACTIVE_ATTRIBUTES);を実行していますが、
// これの結果がスマホだと、その、pickで、なんですが、lightと異なるんですよ...
// パソコン：lightと一緒で4つ（cubeが持ってるのは2つだけど）
// スマホ：aPositionのひとつだけ。わぁ。
// そういうわけでaNormalでエラーになったわけね。そういうことらしいです。わぁ。。。

// 気を付けないと。ほんとに。要するにactiveの判定の仕方が処理系によって異なるようです。

// gl.getAttribLocationにしても、これシェーダープログラムを指定しますけど、
// 結局のところこのシェーダープログラムのこのattribute変数に割り当てられているレジスタ番号はいくつ？ っていう、
// レジスタ番号を問い合わせるためのただの便利機能（実際は異なる）

// 今回のことを知らない人がこのgl.getAttribLocationの関数仕様を見ると、
// シェーダープログラムの切り替えで頂点アトリビュート（レジスタ）の状態も切り替わるって思っちゃっても
// 不思議はないですよ。実際は違うわけですが

// VAOってuniformのあれと同じなのかな...

// なんかあんま参考になってないけど、いいか。

// 登場するすべてのattributeに出現順に0詰めで番号を付与してそれを使うようにすれば
// もはやprogramは不要で
// つまりどっかのProgramには登場するから登場した際にそのlocationをattributeに記録させれば
// もはや問い合わせは不要で...
// 今回みたいなことが起こるんだったらgetProgramParameterベースであの処理を書いた方が良さそうね
// ただそこに現れるのに存在しないattributeについてはどうする？programサイドはlocationを提供してくれているが
// エラーになるね。
// 結局のところ、あそこに「どっちもundefinedでない場合だけ有効化しなさい」って書けば済む話なのでは？

// if(vbo === undefined || attr === undefined){ continue; } // これを追加する
// これで行けると思う。てかこれがあれば何も起きなかった。それはそれで怖いわね。

// おそらく既知情報なんですけどuniformのlocationはオブジェクトなんですね。ほんとうにprogramごと。
// 対してattributeのlocationはレジスタ番号。整数。しかもさっきの話だとprogram関係なくて、出現するattributeごとに用意されるっぽいね。
// 違うaPositionが出てくる場合は...調査中。
// 今回は同じvboで違うprogramってケースだから。違う図形とか扱う場合はまた別の問題が生じるのかも？さっきの話また読んで勉強しないと。

// 提案
// frustum廃止して"rect"ってモード作るわ。
// "rect"は基本的には一緒なんだけど、上下左右のrectの位置をcenterを通り視線に垂直な平面内で
// 実際の長さで指定する。
// 多分p5jsもこれを想定していたんじゃないかと推測してる。だってあれがデフォルトっておかしいでしょ。
// まあいいや。そんな感じ。
// nearで、しかもnearと同じ中心までの距離との比率で定義するってめんどくさすぎるでしょ。
// orthoやperspectiveと比べて絶望的に分かりづらい。なんでnearなのよ。
// 中心のところであれば大体のスケールを把握しやすいから便利だと思うのよね。

// カメラとTFを整理する前にやってしまいたい...

// readPixelsとgetAttrInfoを実装します。
// readPixelsについて、h_doxasさんのこの記事は参考になります：https://wgld.org/d/webgl/w086.html
// 制約：colorで、textureで、0番で、bindされている。これらの条件を満たすtextureから、
// pixel値指定で（0～1ではない）入手できます。
// 1x1でピンポイント指定したいならば0.5を足すべき、ですかね。linearであれ、んー。そこはまあ...
// たとえばlinearなら挙動も変わるのかもしれないけどわかんないな。wrapはどうか？さぁ...

// ----------------- //

// 20221021
// TODO

// 1. mipmapについて。
// まずmipmapですがMINだけです。ちゃんと！！ちゃんと読んで！このポンコツ！！
// なので個別に設定できるようにします（mag,min,sWrap, tWrap）。この際全部。
// 同じでいいならmagとsWrapだけ指定すればいい。というわけでfilterとwrapは廃止するのであちこち変えないといけないのだ...
// （当然だけどこういうのは静止画用の話で動画の話じゃないよ、それだったらbloomみたく毎フレーム用意するか、
// ...まあいいや。で、まあ静止画、それも縮小する際に不具合が生じる場合限定ですね。）

// 2. copyPainterの拡張について。
// 次にcopyPainterですがrectを複数用意する形式で書きたいです。で、あの、alignを設けて、まあデフォは左上指定にして、
// alignで左下指定に書き換えてシェーダーに渡してそっちで頂点の位置いじってってやる。UVもいじって貼り付ける。OK.
// 統一しよかな...Array.isArrayがfalseなら[{}]ってすればいいだけの話。
// そうなるとviewsとかするんじゃなくてinfoの中にviewって書けばいいかな。
// しかしこれ、全体に対する...んー。そうなるとviewって不要だね...
// だってviewで範囲決めてその中で...っておかしいでしょ。全体で、その中で、ってしないとだよね。そうしようね。双子葉植物。
// それとは別にviewも。viewとは別に、viewsの代わりに...忘れちゃった、viewsでいいや。
// 各infoにviewを持たせるということですね。alignで指定方法をいじれるといいですね。
// あとfboがdoubleの場合は一番最後にswap, これもデフォルトfalse, doubleならデフォルトtrue, にしようか。
// たとえばポストエフェクトだとか、あるいは乗算やオーバーレイをベースに掛けていく場合なんかに最初になんか置くということを
// 考えると大事かなと思うので。そういうの、doubleの方が都合がいいでしょう。あるいは将来的にポイントスプライトをバラまくとか。
// そういうことにも使えると思う（GPGPUデータ格納など）。
// アイデア無いけど（でもまあswapは大事）

// 3. spotLightについて。
// 次にspotLightも実装しよう。
// これでpunctual系は揃うけれど...どうしよ、メビボさん(mebiusBoxさん)のコード真似しようかな...迷うわ～
// 最終的には物理ベース行きたいし。でもまあ一応真似する方向で。
// 次に、あのコードをディファード用に書き換えるのはもう簡単。ポイントはmodelPositionを引数にして
// グローバルじゃなくても困らないようにすること。それくらいです。
// 整理するのに構造体を使うことも検討...mebiusBoxさんがそれでやってたので。権威には従うべき。

// あとねぇ（まだ何か...？）、カメラのヘルパー欲しい。線でいいから。カメラセットするとヘルパー描画してくれるの。
// frustumの線だけ描画する。何処が描画されるのか一目瞭然。
// 加えて深度値もくっきりするのでそこら辺のデバッグにも最適！
// 座標軸のヘルパーもほしいかも。長さを入力する...

// depthのテクスチャか。どうなるんだろう。テクスチャの中身か...気になるねぇ。
// せっかく4画面あるんだから別視点とかやりたいねぇ。
// あとpointLight, directionalLight, spotLightそれぞれについて影！ああ、やることが多い...！

// foxParseはいい経験になった。でも「失敗」という経験というほかないですね。
// overlayなんてshaderなら一瞬なのに。
// foxParseみたいな失敗作どうでもいいからマニュアルやチュートリアル作るんならp5wgexのそれを作りたいわね。

// 20221022
// magFilter, minFilter, sWrap, tWrapに改名。冗長かもしれないけどwebglに敬意を表して省略はしません。まあ、問題を防ぐためにも。
// エラーが出たらその都度直せばいい。いちいち気にするのは疲れるので。

// copyPainterはまず4枚のrectを用意してそれらの頂点はいつもの-1とか1で正規化デバイスでそのまま使う、で、
// おやすみなさい

// Quad作った。countを考慮して4,8,12,16で描画する。view指定はinfoにぶちこむ。で、flipするかどうかもinfoにぶちこむ。
// 配列でない場合は[]でくくる。で、viewはalignに応じて左下ベースで修正する。で、fbでdoubleの場合はswapをtrueにする。
// swapのデフォルトはfalse.（当たり前） alignのデフォルトは"left_top"とする。flipのデフォルトはtexならtrueでfbならfalseで
// flipはUVを送るときにvertexShaderで行う。以上。

// 20221023
// varyingでintを使うときはflat修飾子を使おうね
// 定義の仕方が変わってる...x,y,z,wで指定するの？？

// 冷静に考えたらその方が分かりやすいから、いいや。

// setUniformがBOOL配列に対応してなかった（おい）
// そりゃうまくいかないわけだわ。本家のp5.jsが対応してなかったからつい真似してしまったのよね。はぁ。
// なるほど整数属性使えないのか...まあ補間できないしね...当然か...

// とりあえず最大8個まで。
// 制限を取っ払う方法はあるけど今はこれでいい
// いつまで経ってもやりたいことができないので前に進むよ。

// デフォルトペインターで軸とかカメラのヘルパーとかね、やりたいし。

// 問題解決しました
// 問題の詳細：
// MRTで4つのtextureに描き込んだものを一枚で描画する際に
// Feedback loop formed between Framebuffer and active Texture.が
// 2回目以降のループで発生しました
// 原因は0番のtextureUnitがからっぽになっていなかったこと
// test19.jsでは何故か発生しなかったが...なぜこっちだけ発生したのかは本当に謎でしかない
// まあいいけどね
// 仕様変更詳細：
// _loadUniformsでsamplerIndexの最大値を取得
// PainterのメソッドであるunbindをunbindTextureに改名（テクスチャのunbindはPainterの仕事）
// これはたとえて言うならパレットを洗うようなもの
// マルチテクスチャの場合全部洗えてなかった
// なのでsamplerIndexの上限に関するデータを用いて
// 全部からっぽにするように指示しました
// shaderを切り替える際には常に呼び出していますが...（Figureの切り替えでは特に問題ない）
// unbindが問題になった初のケースなので割と混乱しました。理解が足りないのです...
// ていうか複数のtextureUnit使ってるのにunbindあれでいいのかってのはまあ思ってはいたので

// すっきりしてよかったです。

// これで前に進めるぞ！！！！！！！！

// 適宜getParameter使っていくかな...デバッグ厳しくなってきたし。

// 割と時間かかりそうだなって思ったけど最終的にPainterのunbindいじるだけで済んだ。
// これが理想的なんよ
// あっちもこっちも変えないとってなったら全部破綻して最悪全部作り直しになってしまう
// MRTに手を出すってのはそういうことなのね
// 冷静に見極めて冷静に対処しないと
// 足をすくわれる

// 20221023
// GLSLって%使えないのか...ところがどっこい。uintで2べきの数字限定ならbitShiftで%に相当することができるのよね。
// たとえば%32であれば32が2^5だから(n<<26)>>26ってやれば桁が溢れて下から6番目以降がすべて消えてそのあと戻すことで32で割った余りが出る。
// さらにずらせば、途中の連続する数桁の取り出し、なんてことも出来るね。応用が広そう。やったぁ。
// って思ったけどflatで渡したら挙動死んだ。無理。

// bit演算の結果を可視化する工夫が必要なんだろう。今はおいておこう。

// もう次行こうよ。

// 簡易GUI欲しいね。Lightの調整とかしやすくなるので。
// デプスをtextureに落としてそれを利用するのテストやってみたい
// あと非同期、now loadingのあとdrawループが始まるやつ、promiseで書いてみたい（そういうの管理するとか）

// 簡易GUIのイメージ
// まずfolder構成とかその、えー、...
// 複雑なことさせようってなったらまた大変だろうけどそうではないならもっと楽にできるはず。
// const gui = guiManager;
// guiManager = (function(){~~~~~~})(); こんな感じ。
// たとえば0～60で1刻みの"c"っていう値があったならguiからgui.get("c")で出るとか。あるいは
// gui.set("c",value)で逆に"c"にvalueをセットできるとか。色だったらgui.get("mainColor")って感じでgetして組み込めるの。
// そういうのほしいから作ってっていう話。めんどくさいでしょテストするのとか。本当に、めんどくさい。
// folderの切り替えもできるように！
// てかlil.guiでやりたい。datは更新終わっちゃったから。
// まずイメージとしては...名前で作る。いくつも作れるんだって。で、オブジェクトが生成されるので...
// gui.create("myController");で生成、使用宣言はgui.use("myController");でこれ以降myControllerで紐付けられた
// objectがノードになる。で、登録はこっちでデフォルト等を決めて...する。folderについて...

// lil.gui:https://lil-gui.georgealways.com/#

// registのtargetを特定のfolderに切り替える。framebufferみたいに。そうすればregistも普通にできるね。
// folderごとに違う名前にして名前空間みたいにしてもいいかもしれないけど今のところ全部違う名前...じゃないといけないみたい。
// うん、framebufferのようにregistの対象をfolder切り替えでそのfolderになるようにすればいいやね。
// nullだったら親に追加する。これでいこう。

// 雑談だと思って聞いてね
// copyPainterの変種、色々作れそうで戦慄してる。
// だってcopyPainterそのまま使うだけでも、中身差し替えて位置いじるだけでスライドとか容易に作れてしまうぞ...
// それにblendを実装するってなったら高速でオーバーレイも乗算も自由自在、ブラーも高速、グローも、...
// はいはい

// あーーーーーーーーーーーーーーーーーーーーーーーーーーーー！！！！！！！

// つぶプロの高速化禁止！！！
// 前に進めない！！！！！！
// 禁止！！！時間の無駄！！！ああああ！！！
// 禁止！

// きつい。
// 貴重な休み...貴重な休みが...！！！！

// 20221025
// リンクエラーになる。同じuniformをvsとfsで使うと。それは駄目だよ、ということ。
// なのでどっちでもviewMatrixを使いたいなら
// 方法1:違う名前にする
// 方法2:同じ名前にして片方から引き渡す（ただし頂点ごとの値をvaryingで渡す形になるので補間の影響...全部同じだから問題ないか）
// uniformは一律なので引き渡しで補間されることはないです。

// 20221025
// 馬鹿か...またやらかした。View行列は4x4でしょう？なぜ3x3だと錯覚していた...！？
// カメラのメソッド追加。ついでにmat4に長さ4の配列に対するあれ、用意して。4つくらい。

// あ～そうか、あの行列「それ」を想定してない...仕方ねぇな。とりあえず全部空にして。
// dataInputとdataUpdate以外なくす。

// 雑談  ------------フルネセレやめようの話-------------
// フルネセレは避けた方がいいね。topベクトルの取り方について。
// 要するに重力と反対方向に取ればいいのよ。だから平面ベースで縦方向に波打つように動かす昨日の螺旋みたいなのだったら
// 普通に(0,0,1)でいいし、あるいは球面やトーラスの上を這うような場合はそこにおける法線ベクトルをtopにすればいいわけ。
// それで普通にtangと外積取る感じでいけると思う。円柱に巻き付くような曲線ならその法線でいいし、みたいな。そんな感じが
// 良いのではないかと思います。カメラワークの参考になれば。

// そういうこと。sliceで取得するとまあ、そういうことが起きる。
// ベクトルくらいですから、ベクトルだけね...
// Vec3だけFloat32Arrayが使えるように仕様変更しました。

// ついでに
// Timerに新機能「getDeltaDiscrete」を新たに追加しました。これはintervalごとに増加する整数を返すものです。
// 要するにframeCountですね。ただ間隔は自由に決められる上、スタートも勝手に決めることができます。
// 離散値が欲しい場合もあるでしょうから用意しました。必要なものを、必要な時に。それが健全な仕様変更というものです。
// でないと混乱する。

// 20221026
// copyShaderで今背景が透明、というか何もおかない場所が透明になってるのだけど、
// 最終結果のaが0のところをどうするかっていうね
// たとえば2種類の色を用意して簡単なグラデーションとか
// あってもいいかもしれないなと。思っただけ。そのくらいにとどめる。混乱の原因になるので。

// ディファードも気になるしもうほぼ完成してる感じだけどとりあえずlil周りを用意してライティング楽にするかな...
// lilを自作ライブラリ化するかどうかは慎重に見極める...要らないかもしれないしな。慣れればいいだけのことで。
// 苦手意識があってさ。払拭したいのよね。

// lilなんかよりマウス操作に関するあれこれを何とかしたい
// たとえばあれにしてもタッチなら同時に複数動かしたりできるわけで。今のところスマホでしか動かないしそれも不満。
// ディファードで負荷を軽くしつつタッチ周りを整えて複数動かせるように、pavelさんのコードで勉強する必要がある。
// てか流体もやってないし。まあ遠い未来の話...その前にCubemap勉強して...んー。webglwater？高負荷だから気が進まないけど。

// 20221026 仕様変更情報。
// getViewFromNDCだけど実際のz座標でやってるんだけど、というかViewの。Viewのz座標って実際の値でやるよりかはCenterとの
// distanceの方が自然じゃない？って話になった、nearとfarもそれで決めているし。でもああいう用途なら実距離の方が自然。
// なのでcenterBased=false/trueを使ってこれがtrueの場合はdistanceとの比率で指定できるようにする（ratioだけ...これをdistanceに
// 掛け算、後は同じ）。

// 仕様変更終わり。そのうちTessSkyもどきを作るときに役立つかも？
// 今見たらtouchとmouseはpavelさんの流体書いたときのがそのまま使えそう。ほんとはTessSkyこれ使って書き直したかった。ただ
// あまりにもあまりにも不評でモチベが砕け散ってしまってできなかった。そのうち劣化コピー作ると思う。その時は
// これをメソッド化したものが使われるといいね。
// たとえば2画面にして別の画面でメッシュが生成される様子を見れるとかしたら面白いかもしれない

// タッチ周りは簡単なコード書いてテストした方がいいわね
// 2Dで複数の正方形をdrag/dropするコードを書いてテストしよう。

// copyPainterでUVのoffset合った方がいいかなって思ったり。
// シームレステクスチャのUVスクロールとかに対応してるといいかもしれないって思った。

// 3D迷路、2画面でやるとか...（？？）

// 3Dお絵描き、ビュー空間であの方法でお絵描きしつつその結果をあのメソッドでメッシュ化してそのうえで頂点登録する際に
// 行列使ってグローバルに変換する形になると思う。あっちはどうやってるのか知らないけど。で、プレビュー表示は2Dグラフィックス使う感じ
// かなぁ。いつになるやら。
// オリジナルのTessSkyはメッシュの頂点登録時にいじってないですね。いじってません。描画の際にTFいじってる。
// まあそれでもいいけどね...んー。んーー...自分的にはアウトかな...って思ってしまう。
// 普通に頂点いじってさ、んでたとえばx軸に平行とかz軸に平行とかそういうの、にすべき？わかんないけど。まあいいや。
// どうせどう作っても

// 仕様変更情報
// 20221026
// CopyPainter. 仕様変更は3つ。
// 1. opacity. 要するに透明度。デフォルトは1とする。掛ける。
// 2. UVscroll. バーテックスにおいて然るべくFlipした後でマイナスする。たとえば0.1マイナスで右下に動く。
// 3. Gradation. 2点指定。指定が無ければいいんだけど。フラグメントでUVの2点を指定して決まった色で（デフォルトは両方0,0,0,0で）
// 片方からもう片方に向かう感じのグラデーションを作ってそれと最終結果でアルファ値で合成する感じ（opacity適用後）

// あと今日思ったのはその、対象と同じViewにおけるz座標ってやったけれど、
// 対象を通りx,y,zのいずれかの軸に垂直な平面内、とかでもいいかなって。
// もしくは対象を通りx,y,z軸に平行な方向に移動するとか。この場合マウス位置というのは厳しいので、
// 対象を通る直線のViewへの投影にマウス位置から垂線をおろしたところ、って感じになると思う。はい。
// あと地味なんだけど、view指定ね、長さ4の配列でも指定できるようにしようね。

// 準備終わったけど...相当テストが要るでしょうね...大変だ。
// とりあえずtest0はokのようです。ここでいろいろ実験するか。

// グラデーションで致命的なエラーが発生してる...UVがおかしいのかな...
// あ、drawElementsにしよう。
// ていうか普通にdrawElementsだろ...何でdrawArraysでやってたんだろ...
// あとdrawElementsの第二引数のcount要らないので排除。

// ああ...貴重な時間が...！！
// 馬鹿じゃん...悔しい....

// swap要らないから消しておいた

// 思い出した。あれだ。flatでint渡すやつ。あれだ。今ならいけるはず。
// そうか...drawElementsじゃなかったからflatで渡したときの挙動が意味不明だったのか...バカすぎる...
// なるほど...ただまあそうね。tint（掛け算）とambient（足し算）用意するか。
// 計算が全部終わってからrgbに掛け算するtintと足し算するambientがあると面白いと思うのよね。
// もっとも...んー。でもまあそのうち、そうね...んー...tintとambientくらいならいいか？

// 直し終わったよ。
// ちょっとショックね。凡ミス。頭の中のイメージをきちんとコードに落とすのって本当に難しいわね。
// 普通に考えれば8つの長方形は別々なんだからインデックスの個数とか考えても
// 明らかにIBOを使って描画するべきなのよね。反省しかないわ。ごめんね。

// 20221027
// まず報告
// flat int で グラデーション、radialも追加で。フラグ0,1,2で管理。それで完成。あとtintとambientも追加で。それでOKです。
// flatでint渡すのできました。
// depthTextureについて。
// Qiitaの記事：https://qiita.com/aa_debdeb/items/128ccb6fa245b6f618b3
// DEPTH_COMPONENT32FはFLOATでいいそうです：https://webgl2fundamentals.org/webgl/lessons/webgl-data-textures.html
// なるほど、これでいいのね。
// あと立方体のメッシュの改良よろしく。Blenderからパクればいいと思う（え）
// でもおそらく:https://github.com/davepagurek/p5.Framebuffer/blob/main/BlurRenderer.js
// こっちが参考になる。おそらくだけど近くが0で一番遠くが1ってのは間違いない。
// depthのクリアのデフォが1だから格納する際の処理は単純に-1～1を0～1に同じ大小関係で入れてるだけ。
// 次の計算：
/*
float depthToZ(float depth) {
  float depthNormalized = 2.0 * depth - 1.0;
  return 2.0 * uNear * uFar / (uFar + uNear - depthNormalized * (uFar - uNear));
}
*/
// 要するに0～1を-1～1に直したうえで、ビュー座標におけるzを出力しているわけ。でもこれ射影変換の行列によって
// 結果が違うよね？Orthoとかだったら別の処理が要ると思うのよね。単純にあれ、クリップミスだと思う。あんまあてにならない的な...
// クリップは大事だなと思わせられたのでした。以上。
// まあでもビュー座標系でのZの値が必要な場合もあるのかな...実際の距離か。あー、被写界深度とかの場合だと実際の距離に変換して
// 比較する必要があるのかもしれない。おいおい勉強していくしかない。とりあえず今はdepthのtextureは0～1. それだけ確認。
// h_doxasさんがうそつくわけないもんね。

// おお...仕様変更ノーミス...！逆に怖い（おい）
// TODO
// タッチとマウスで処理分けるやつを
// それとディファード、それで一応あれは完成。さめがめ...作ってみたいね...
// lilもサンプル作ってみるのと、デプステクスチャの目途が立ったのでやってみる（ほんとに0～1だそうなので）
// それで簡単な影、簡単な反射、とりあえずの目標はそこら辺。立方体のメッシュ改造するの忘れないで。UVも付けて。

// touches使う？...

// グラデーションのところ、やっぱ result.aと1-result.aでブレンドした方が良さそう。テキストが汚くなる。こっちが正解かと思います。
// 難しいね...
// はい。よくできました。で...
// Timerなんですが...

// ---------------- 停止と再開 ---------------- //
// うん。今のままだとquitが出来ないですね...もちろん解消する方法はあって、んー...
// たとえばdurationを使わないのであれば、...
// 個別に？？
// 個別にか。その場合アイドリング時間を記録する必要があるのよね。で、終わったらその分を引く...つまりスタンプから引く。
// 引かないでDeltaを取るとアイドリング時間が加算されてしまうので。そんな感じですかね。なので、それを処理するために、7
// lastStoppedを追加。lastStoppedは停止するとき記録され、再開したらperformance.now()を取得して差を取ってその分を
// Stumpから引く。こうすることで？？
// ちげーよ。逆！足すの！！
// 足すことで引き算の結果がちいさくなるんでしょ。足すの！！え？
// あ、確かに...足すんだわ。10でチェックして30～60でアイドリングして80でデルタを取るとかそういう場合、
// 60のところで10を40に更新しないと正しい値である40にならない。70になってしまう。OK! なんとかするわ。

// pauseとstart. lastPause. これでいこう。
// pauseとreStart実装、重ね掛けも回避、onChangeまでテスト完了。

// copyPainter最後の仕様変更。uvに掛け算を許す。これが無いと片手落ち。
// そして20221029.

// copyPainterをdoubleに適用する際の「常にswap」は取り消し。
// 20221029
// copyPainterちょこっと仕様変更。全体のviewportもいじれた方がいいかなって。でないと常に全画面になってしまう、
// それはちょっと柔軟性が欠けるねって話になった。
// それとuvの掛け算。とりあえずそれで。終わりで。はい。

// 20221030
// ドローコール減らそう
// まずplaneとtorusをまとめる、0,1,2,3,4,5,6.
// 1～6はtorus, 例の方法でメッシュをまとめる。全部デフォルト、z軸に突き刺さるのでOK.
// んで4x7のframebufferで4x1ごとにmodel行列を生成するshaderを作るだろ、modelMatrixBuffer(MMB)を作って読み込ませることで
// modelMatrixの代わりにするのでもうtfは要らないし、vとpとvpしか使わない。
// それとライト増やす際にもうこれただのマスクだからfb増やすだけで増えてく感じで
// ライトの数だけRED32fのフレームバッファを用意する感じ
// それをライティング計算で...んー。後回しでいいか。あのあれ。
// マスク作ってからそれを使って補正、のところをカットしてマスク作ったらもうすぐにcolorに落とす感じにする。というか
// fbのtextureとcolorでくっつけて、ってそのまま出しちゃおう。

// planeはtexture描画でチェック模様、torusは0,1,2のいずれか選べるように、頂点色はあらかじめ用意しておく。
// planeも用意しておく（全部白でいい）、UVはcompositeの際はいっしょくたでOK（どうせ分けるなんて無理）。

// 負荷が重いのが続いたね。
// 軽いのやりたい
// とりあえずあとトーラスノットと大量の四角形で影やったら次行こうかな
// ...
// 方向性間違ってないよね？
// 間違ってる？間違ってるかもね。
// 間違ってるなら修正しないとね。
// コラッタ描きたい

// 言いたいことはわかるけど
// 一度は通らないといけない道を通っただけ
// 複数モデルの結合とかモデル行列の動的更新とかいろいろ道具は手に入ったし
// なにより影作成の手ごたえつかんだのが大きい
// 無駄とかいうな
// まあでも黒歴史が増えただけだわね。そうね。

// 時間制御のパワーを実感したのでFALさんのあれをWEBGLで書いてみるのも
// ありかもね

// copyPainterのバグ分かった
// 20221101
// FBOを一時的に変更するって話だったのにそれ実装してなかったのよ
// 実装するためにあの関数用意したのに...
// というわけで実装します。これでいろいろ解決する...

// 2枚のテクスチャを受け取って適当に合成してFBOに焼く
// swapは必要なら外部でやればいいので
// もしくはテクスチャにフィルタを掛けてFBOに焼くなど（ブラーとか）
// ブルーム。解像度指定してフレームバッファたくさん用意して落として戻す
// もしくは....
// あーじゃあ、Bloomと2D組み合わせるのを
// なんか自作の
// もういい
// あるいは過去のwebglプログラムを書き直す
// テクスチャペイントの原理
// いつものディファードでUVも落とす
// マウス位置を中心とする円に対してポイントスプライトを生成して
// 載せる画像から色を取ってさっきのUVmapからUVテクスチャ上の色を取っていつものように点描画
// ほんとうにただそれだけ

// まあ難しいよね。テクスチャペイントはBlenderでやるものです。
// さてと
// 3D迷路にスペキュラー導入したいかな。何とかしよ。カメラ動かせるようになったし。ポイントライト、目の前にスポットライト、斜め上から
// 方向ライトでON!

// おしまい。

// FALさんどうこうじゃないでしょ
// 甘えても仕方ない

// もう疲れた


// 20221107
// お久しぶりです。
// setUniformがエラーを返すところで、失敗した場合はnullを返すようにしました。こうすることで_nodeがnullに対して実行できないので
// 処理が止まってくれるはずです。
// 他のalertを出す処理も軒並みnodeでなくnullを返すようにしておきました。

// 20221107

// さてと、createCanvas自作するか。
// 趣旨としてはmainタグの中、もしくは指定したidのタグの中にcanvas要素を生成して好きなid名とClass名を付けてってやるだけ
// です
// createGraphicsについては指定したidのタグ、もしくはbody内に
// RenderNodeって何だっけ...ってところからかな。
// RenderNodeも結局glってこれがWebgl2RenderingContextなので、キャンバスに紐付けられてるのよね。そしてframebufferという概念がある。
// これはcanvasではないのよね。テクスチャやレンダーバッファの集合体。要するにただのバッファなのよね。まあ、オフスクリーンキャンバスも
// バッファといえばバッファだけど...(rgba256限定の)
// createGraphicsのWEBGLは現在のところそういう位置づけではないので、というかあれを使いやすくしたのがRenderNodeなんです。
// だから堂々と2d版のRenderNode, RenderNode2Dを作っていいと思う。

// それらはいずれもキャンバスに紐付けされる、ただ2Dの場合FBOに相当する概念が無いので、まあとはいえテクスチャとして再利用するのが
// デフォの使い道だから別にどうでもいいのよね。fps表示したりとか。BlendModeにしてもwebglでやるものだしデフォルトペインター増やせばいい。
// よし。作るか～。何を？？

// だよねぇ...

// ていうかキャンバス用意するところからっていうならRenderNodeの初期化のタイミングでそれをしないといけないのよね。
// んで2Dもその方向でって流れ。んーーーー。

// お疲れさまでした。新しい方向性を探しましょう。

// 20230317
// Hello.

// 色々ありました
// ありすぎてもう何から話せばいいのか
// 海で泳ぎました（冬に！！）
// 元旦水泳。
// まさか12月に泳ぐとは思わなかったけど気持ちよかったのと
// プルリクに携わったりしました
// 1月にも海で泳いで
// 2月も1回だけ
// 3月も海で泳ぎました
// 3月が半分終わりました
// 健康診断と歯医者が終わりました
// ...スパイファミリー面白いです
// で？
// p5.jsは1.6.0になったんですが
// 次のバージョンからwebgl2です（ほんまか）
// さらにフレームバッファ導入とか
// それはどうでもいいんですが...こちらの進捗を調べに来ました
// function _getTextureDataFromSrcにHTMLCanvasElementを導入する？のところで切れてますね
// それ以前に
// 使い方忘れてるよ！！！！
// 復習しないとだよ！！！！
// GPUパーティクルも移植できてないしいろいろダメダメだよ！！！
// 影とかディファードはとりあえずいいです
// GPUパーティクルとブルームと流体ですね

// とりあえずこの3つですかね
// それとねこいりねこ
// そこら辺を目標に
// でもですね
// お絵描きの練習したいんですよ...
// もうこっちはいいから。別の方向性...海で泳ぎたい！！
// どうせこんなのガラクタ
// 捨ててしまえ
// ぽい

// まず
TODO
// gradationFlagはStartとStopがundefinedでなければtrueになるようにしましょう
// alphaの計算が合ってるかどうか調べる必要がありますね...
// それと
// とりあえずいいや

// コロナとか色々あって大変でしたね
// 頑張ってコード書いたのに報われなかったり
// それでも頑張る君は
// かっこいいよ
// おやすみ

// window.alert使うとデバッグが中断されてウザいのでやめてください
// 一掃して
// というわけでまずはwindow.alertをなくしましょう
// エラー処理しにくくなるので

// エラーが発生した場合に処理をすべて終わらせればいいのよ
// ループが実行されないようにする
// プログラムの最初にexの拡張機能であるフラグが立っている場合に自動的にdrawを実行しないようにするとか
// もしくはもう単純にすべてのコンソールエラーが1回しか実行されないようにする
// noLoopでいいか
// じゃあ一か所にまとめて
// エラー処理のためのグローバル関数を用意したうえでその中でnoLoopを実行すればいい

// おいおい実装しますね

TODO 2023/03/24
// window.alertにおいてシステムが異常停止してしまうのをnoLoop()により回避する
// ブルームと流体を移植
// GPUパーティクルを移植

// やる気ある？

// 2023/03/27
// 1つ目なら。

// コミットしました。
// たとえばユニフォームエラーなどで止まるわけです
// シェーダ内でユニフォームを使わない場合にエラーが出るやつです（宣言したにもかかわらず）
// それによるストップを止められる...はずです。

// alert地獄おわりました。

// tfのscaleなんだけど
// 引数1つのときにそれが全部適用されるようにできないですかね
// drawBuffersScaledがそうなってないんだけど合わせなくてもいいでしょ

// dollyですね。これを対数にする...のか？
// 変更点1: dollyについて対数ベースにする。ベースは10でいい。log_10でnearとfarをあれしてマウススクロールで
// 自然に変化するように。変化量は0.03がよいです。
// 変更点2: rotateを導入する。これはある軸の周りにすべてのカメラ座標軸ベクトルを回転させる。それだけ。後は一緒...
// ではないな。視点が変わる。視点だけですね。
// cielはtopを記録しておいて戻すためのものらしいですね...回す分には問題ないか？そうか。んー。
// なので普通にまとめて回転させてOKだと思う、うん。
// rotateの場合は常にcielをtopに設定して問題が発生しないようにしよう～？
// あ
// なるほど...topか。そういうことね。topね...
// 重力が無ければ考える必要ないかな...
// 画面揺れを防ぐためにtopの概念を導入したんですが、自由回転においてこの概念は不要なので...困ったね。
// sideは中心に対して右。upは中心に対して上。そしてfrontは中心から視点方向。topというのは、
// 要するに重力の逆向きで、centerとeyeから作るfrontベクトルに対してupを計算する際に使うのだ、が、
// upが予め指定されるならこの概念は不要なのよね。そもそも行列にも反映されないし。
// どうしようね。
// rotateでtopもcielも全部upにしてしまえばいいんだ。問題解決！！
TODO
// 1. Vec3にcopy()を導入：できました。
// 2. dollyの距離変化を対数ベースで書き直す
// 3. カメラにrotateを導入。topとcielはその際upで上書き。
// 4. orbitControlはrotate,dolly,moveをタッチとスマホで行なうものとする
//    とはいえ通常のvRoid方式のオビコンも必要かもしれないな...応相談かなぁ。
// orbitControlのタイプ2つ。type:"semisphere"とtype:"global"でいいでしょう。
// semisphereは通常のオビコンで、topベクトルを固定しつつ、上下に制限を設けてtopの周りに回転させる感じ。vRoid的な。
// globalは今作っているような、あらゆる方向からなめまわすやつ。この2つです。
// orbitControl("global"); もしくは{type:"global"}って感じですかね。orbitControl({type:"global"}); か？
// 5. p5.Vectorのプルリクでベクトルの周りに回転させるのを実現する。向きは一緒で。

// 2023-04-10
// Vec3にcopy()とtoString()を追加
// 2023-04-10
// ちょっとしたtypoを修正
// exIAとexOCを導入。

// 2023-07-14
// プルリク終わったのでフィードバックを始めます
// 手始めに
// すべて破棄して作り直します
// こうゆうのあると便利っていうのをリストアップしといて
// モデルのローディングもきちんと向き合って
// 作れるように
// freeRotationとか作ったんですよ
// こっちでは使えないわけです
// あほらしいだろ
// p5.jsの方が便利とか
// ふざけてる

// orbitControlを独自に修正してこっちでも使えるようにしといた
// perspectiveで普通に機能します
// upをtopで言い換えるだけでOK

// 2023-07-27
// いろいろ課題が山積み

// まずカメラですが
// 1.7.0のorbitControl()を間借りしてます（自分で開発したんだけどね）
// ただ
// 自前のイベントリスナーシステムでやりたかったので
// そこはう～んってなっちゃうわけです
// フレーム制御なのでそこら辺の不満もあるし
// フレーム制御なので...
// あとorthoですが
// ぶっちゃけorthoとperspectiveだけでいいんですが
// カメラのslerpもきちんと移植したいんだけど今はこれでいいですいつでもできるので

// 移植について
// sandですかね
// boidsかなぁ
// 3次元のboidsも移したいね
// fluidとか
// できれば、webgl water...は、まだ敷居が高いです...
// bloom
// particle-bloomなどなど
// bloomは不満な点が残ってるのでね
// p5のtextureシステムがクソなので

// それとは別に
// disableVertexAttribArrayを導入するか否か
// これは問題が生じてからでいいと思うけれどね
// 要するにshader内の使われないattributeがあるとまずいわけ
// shaderを走らせる際に使うattributeを逐一精査して
// 供給が無い場合にオフにする処理をp5の方に導入してこの手の機種依存のバグを解消したんですけど
// p5wgexがそうなってないのです
// 今のシステムだと
// たとえばshaderで0,1,2なら0,1,2すべて使われるし
// 0,1,2,3,4なら0,1,2,3,4すべて使われるって感じになってるから
// 汎用シェーダが無い状況だから問題が生じてないだけかも
// 加えてスマホでしか起きないので確認しづらいと。

// sand
// boids(2D,3Dもできれば)
// particle
// bloom
// fluid
// ツチノコさんのあれ、遮蔽のやつ
// orbitControlとfoxIAは共存できるのか、とか。
// ていうか
// そもそもorbitControlの改良のためにfoxIAを開発した経緯があるんだけどね
// 共存どうこうではなくそもそもfoxIAでorbitControlがやりたいのよね
// あとウサギ
// きちんとやりたいですよね

TODO 進捗
sandをp5wgexで書き直すのに成功しました
次のtargetはboidsです
boids一応一段落
次は富士山のメッシュの雪以外
雪がスマホでおかしくなってるので
インスタンシングで1000個くらい球を降らせたい
その前にジオメトリーとかその辺整備するか....

vertexAttribArrayっていうのがあってですね
すべてから独立したvertexAttrib（レジスタ）の配列です
vertexAttributeのことをレジスタって呼んでたんですよ
ここで：https://qiita.com/emadurandal/items/1812198d562bd1216c70
ここでも：https://qiita.com/emadurandal/items/5966c8374f03d4de3266
後者の方ですね。
enableVertexAttribArrayで番号を指定するけどその番号っていうのはこの
vertexAttribArrayの配列のインデックスみたいなのよね！
その前にbindBufferしてるでしょう
これらが実行されたうえで
vertexAttribPointer(attr.location, vbo.size, vbo.type, false, 0, 0);
すると
attr.locationがenableされているわけですけど
んーそう
だからattr.locationって書いちゃってるけどattributeのlocationというより
そのattributeがshader内で呼び出される際の、vertexAttribArray内の配列番号ですね。
データが入る。
で、他のshader使う際にその番号が有効になってるのにデータが中途半端に入ってて足りないとエラーになって処理系バグが起きるんですけど
今の運用ってshaderのattributeは過不足なく使われてるから問題が起きないのですよね。以上。
問題が起きそうなのはlightingShader使う場合とか？だからそれに備える必要があるかも？
有効化とbindは無関係な処理なのでごっちゃにして扱うのは良くない
vaoとか学べばそこらへんきちんとできるようになるかも。

h_doxasさんのあれ使うとそこら辺の理解に支障が出るっていうのは間違ってないのよね
実際ごっちゃになるでしょあの説明だと
...
VAOねぇ。やる？
VBAじゃないですよ。VisualBasicじゃないですよ。
VAOです。勘違い。VBAって書いてあった。ばか？

h_doxasさんの https://wgld.org/d/webgl2/w006.html では（VAOの例）
fbにトーラスと球描いてそれを落としてますね
このやり方は応用が利くんですよねこれじゃないと距離フォグとか使えないしいろいろ不便なので
daveがやってましたか？
まああれは...つかいたく、ない...

インスタンスわかってきたぞ
そうか
あれトーラスの情報、v,n,uvは1個分か。で、インスタンスがあるとそれの内容全くそのままでインスタンスの分だけ余分にレンダリングされるのね。
そして
除数が1だと個別だけど3だと3つずつ同じになるわけだ。はい。わかった。
p5の方紛糾してるけど無視
なるほど
要するに掛け算の要領なのね
コピーを作るわけだ
じゃあまずVAO...
VAO無しのインスタンス化もやりたいですね
しかもIBOアリと無し
え？
ということはバリエーションいくつ...
まずVAOつかうかどうか
IBO使うかどうか
4通りあるわけですね
8通りあるうちで今使えるのが
IBOありなしの2つだけというわけですね

全部できるようにする。
Figureがそもそもvaoの構造を備えているんよね。だからFigureをvaoかどうかみたいにすれば問題ないかと思いますよ。
とはいえ
まあいいか。やろう。
内部処理の有無だから差し替えちゃっても
いいわけないか
registFigureであの、うん。useVAO.
Figureの拡張ではなく...
Figureの中にindexBufferの情報を入れられないので今の路線で行くとindexBuffer込みのVAOは作れなくなるわけです
それは不便なので
新しく作ろう。AFigureにする。んー。
VAOFigureでいいか。indexBufferを使えないのは痛いからね。

VAO作るんですが...困った
そうか先にlocationを決めとく...shaderサイドで決めるんじゃなくて？
attributeのlocationはprogramから取得するからshaderベースの情報だと思ってたけど
それだとまずいわけだ
個別の処理なのか
うーん
h_doxasさんの：https://wgld.org/d/webgl2/w006.html でもgetAttribLocationは使ってないですね。わぁ。
使わないのね！？
うーん...使わないのか...
shaderと呼応させることが前提で恣意的にlocationを個々のattributeに持たせる必要がある、というより
持たせないとvaoを作れないわけだ。わぁ。
わかりました...

VAOFigure一応作りました...
iboの場合はiboのデータとinfoを用意します
とはいえdataとlarge以外基本的には設定しないですが。

bufferSubDataをvaoとiboでも使えるようにした方がいいかもしれない。出来ないので。現状。
vaoを用いるがiboはbindしない場合？あー...そうね...
まあ、レアケースだけど無くはないか...
そもそもiboを複数用意するのは珍しくはないのですよね。線と面とか。色々あると思う。
その場合であってもvaoを使いたい場合、ARRAY_BUFFERだけvaoで用意して、ibo部分は個別にbindする可能性もあるのですよね。
というかvaoであってもその中のibo部分を上書き出来るので...bindIBOは普通に呼び出せるのよね...どうしようね。

VAOFigureの中でiboを扱うのを、やめればいい。
ですね。そうしましょ。ややこしくなるだけですからね。やめよう。ここでやめておかないとあとあと面倒になる。

テストとしては
registVAOFigureであっても普通に描画できるか
IBOと組み合わせて描画できるか
複数のIBOでそれぞれ描画できるか
bufferSubDataはVAOでも通用するのか
この4点ですね

インスタンス化について。
VAOを使わない場合、vertexAttribDivisorを呼ぶか呼ばないか、という話になる。
呼ぶ場合、除数でインスタンス化されるわけ。
とはいえ、通常のdrawArraysを使ったのでは、1回につきひとつしか描画されない（未検証...おそらくそうなる）
drawArraysInstancedを使った場合に、1回のドローコールで複数描画される（個数は任意）
indexBufferがbindされてる場合は、それぞれElementsで同じことが起きる...はず。
VAOを使う場合も中でvertexAttribDivisorを使うだけで、全部同じ。です。

vertexAttribDivisorを呼ぶかどうかについては、divisor:0,1,2,...
でいいかと
デフォルトを0としてバリデーションのところでundefinedならば0にする
0なら何もしない
1以上の場合にbindされていたらこれを呼ぶ形ですね。いつ？バッファのAttribの最中。ですから、
VAO未使用であればenableAttributesの中で実行する。その...そうです。で、最後に一行追加する。
VAO使用する場合でもcreateVAOで同じことをするだけ。
ロケーションと除数しか使わないのでらくちん

attributeのバリデーションをVBOsやVAO作成時にしました
同じコード書くの気持ち悪いので
2箇所で同じバリデーションやるのは頭が悪いので

インスタンシングの準備が終わりました
テストしましょ
インスタンスアトリビュートがあってもdrawArraysだと1つしか描画されないのかとか色々調べる必要ありそうです
bufferSubDataのテストもよろしくね

インスタンスの場合、どうなるんだろ...普通の描画はできない？のか？個数が違うからなぁ。
一つでもあったら駄目な感じなんだろうか。そこがよくわからんのよ。
とりあえずインスタンスできたっぽいです
VAOはいろいろ問題なようで...TransformFeedbackでも使えないし。まああの機能も...
...
はい。
vaoで動的更新やってみるよ。bufferSubDataでしょ？
indexBufferに対してもできる。それには...

bufferSubDataのiboへの対応できました
Uint16Arrayの場合は2バイトずつズレるのでそこに注意ですね
線の繋ぎ変えとかできるわけです
Uint32Arrayの場合は4バイトずつですねぇ。はい。

トランスフォームフィードバックについて
これもそれで速くなるのか？って感じだけど。暇ができたら、やろ。

インスタンスちょっとがっかりした...

gl_Positionって書いてあるんだけど
gl_Positionも指定できるってことでいいの？そこら辺がよくわからん。
ラスタライズしないから可能ってことなんでしょうか...うーん。なぞ。
トラフィーの出力に使われていたvboが今度は入力で当たり前のように使われてて困惑するね...
今の枠組みだと厳しそうだわ。部分的にアタッチする技術が要るかも？
って思ったけどshaderサイドで要求が無ければ使われないのよね。んー...
違う名前でも同じ名前でもOKなら混乱を避けるために同じ名前にしたいところだわね。どうしようね。

swapさせるとか？
最初の書き込みではaPosition, aColor, aReadPosition, aReadColorとかって用意して、
次の読み出しのときにswapして書き込まれた側がaPosition, aColorでアクセスできるようにすれば
enableAttributesの際に書き込まれて読み出しに使う側がaPosition,aColorになるよね。そういう感じか？
で、そのあとで戻せばいい。このデモの場合は。
swapAttribute("aPosition", "aReadPosition")
swapAttribute("aColor", "aReadColor")
drawTFFigureとかする
drawFigureの場合と違って
outVaryingsの中身である場合には異なるbind関数を使って最後にbeginTrans~~~する感じ
"points"などの引数が必要ね
RenderNodeにtransformFeedback中かどうかのフラグを持たせてunbindの際に工夫させる感じですかね。
ラスタライザディスカードは実行しない場合もあるようです。知らないけど。
TFFigureはFigureと違ってoutVaryingsの情報を持ち合わせており...
attrのプロパティとしてdivisor(0,1,2,...)を用意したけど、さらにfalse/trueのoutVaryingが要るかも。outにしよう。
デフォルトはout:falseでこれをout:inにするとそういう扱いになる。で...
shaderも特別なものになる。
registTFPainterという新しい関数が必要。逆にTFFigureはoutのプロパティがあれば要らないかも。VAOは禁止。
TFFigureをやめる代わりにdrawTFFigureとTF状態であることのフラグが要るんじゃないかな。
TF状態でunbindが呼ばれたらoutのものについて...
outIndexにするか。デフォルトは-1で、これを0,1,2,...としてvaryingsの何番目かの番号を入れる。
この番号が重要なようですので。困ったね。だからfalse/trueではなくて-1/0,1,2,...の方が合理的かも。
outIndexだけあればいい。attrLocationはどうせ描画時まで決まらないからね。

outIndexのデフォルトは-1でこれを0,1,2,...に設定することでTFを実行する。インスタンシングでdivisorを設定するのと同じ。
とりあえずoutIndexだけ作りました。
じゃあregistTFPainterも要らないわけね。
おそらくregistTFPainterも要らないですね。
VAO出てこないので（うれしい）
enableAttributesの分岐処理の非VAOサイドを書き換えるだけでいいと思う
ああフラグ要らないですね。
？
要ると思うよ。だってoutIndex>0であっても通常のbindを実行するケースが考えられるからさ。難しいよねぇ。
というわけで、要ります！
RASTERIZER_DISCARDは文字列で辞書に登録しました。

準備完了、かもしれない。
TFできました～🎉
ライティングですが、全体で一つのシステムにしてもっと設定しやすくする必要がありますね。
shaderも部分的な書き換えをもっとしやすくしないと使いにくいです。バラバラにして、分かりやすく、
TODO
あとディファードのテンプレよろしくね。フォグやりたい。
ディファードのテンプレ一応できたんですが忙しくて何にもできません
インスタンシングとTF組み合わせ...時間がない。くそったれ。くそったれ。

https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/pauseTransformFeedback
transformFeedbackを中断できるらしい
何だろうね
一時的に従来のドローコールに戻すんかね
わからん
https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/beginTransformFeedback
beginTransformFeedbackの引数のドローコールは
POINTS, LINES, TRIANGLES
しか選べないようです。まじか！書き加えておかないと。

TODO
あとさ
vsとfsでvaryingの対応ができてないのとかコンパイル時にチェックしてくれるとありがたいね
getParameter系ではむりっぽいので文字列解析でやるしかないと思う
しくよろ～

antialiasがfalseの場合にテクスチャパラメータが無効化される問題。？？？？
ネイティブでもそうなのかしら。

ライティングについてはいろいろとっかえひっかえできる形で定式化しないと使えないと思う

CUBE_MAP難しくないかも
TEXTURE_2Dのところを変数化してtexImageのところをいじる必要があると思う
あとはまあ更新をどうするかということ。
samplerIndexの他に、2Dかcubemapかの情報が無いとunbindとかbindのときに困ると思う
それはshaderの解析時に...samplerIndexを設定するときにメタデータを増やせば対応できると思う。

uniformの型一覧：https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getActiveUniform

ですから、gl.SAMPLER_2Dの他にSAMPLER_CUBEがある。
おそらくこのSAMPLER_CUBEになるときに...そういうことですね。
たとえば
uniform.samplerType = "2D";
とか
uniform.samplerType:"cube";
とかそういうコードが必要になるかと。

他にも色々あるようだが...今は関係ないな...

dictのリストにSAMPLER_2DとSAMPLER_CUBEがないので追加しよう。で、
...追加しなくていいか
TEXTURE_2DとTEXTURE_CUBE_MAPを追加する。で、
uniformに持たせる、アクセス文字列を。アクセス文字列っていうのは要するにdictに放り込んで
TEXTURE_2DやTEXTURE_CUBE_MAPを取得するための文字列ですけど。それですね。それでいいと思う。
んでtexture側にも同じ文字列を持たせて処理の際に参照するようにすればいいと思う。いいですね。
はい。んで各画像が想定通りに出力されるかどうか調べたいですね。

TODO
randomもそのうちex.random()とかしたいですね。ベクトルのランダムとか出す関数とか実装したい。球内の点ランダムとか欲しいんですよ。

というわけでインスタンシングとTFを組み合わせることに成功しました。
ポイントはインスタンシング用のattrについてはTF中はdivisor設定のbindをしないこと、また
drawArraysやdrawElementsでcountを自由に決められるように処理を書き換えること...まあTFはArrays限定だけどね。
で、インスタンシングのattrの順番ですが、インスタンスの個別attrは固めて置いてくださいね。基本ですよ...

CUBE_MAPについて...

// まあ無いと思うけどそれぞれをcreateGraphicsで作る場合とか...?
// あーそうか、MRTで作るとかできるのか？6つなら許容範囲のはず（上限は基本的に8なので）
// できるかな...できるでしょ。
// console.log(gl.getParameter(gl.MAX_COLOR_ATTACHMENTS)); // webgl2では8（この処理系で）
// console.log(gl.getParameter(gl.MAX_DRAW_BUFFERS)); // webgl2では8（この処理系で）なので6つくらいは余裕...
// h_doxasさんの動的CUBE_MAPのやつでは、フレームバッファにアタッチするテクスチャをCUBE_MAPにしてカメラをその都度切り替えて
// 6面分描画するみたいなことをやっていますね。わぁ。しかも毎フレーム...で、そうするとちゃんとCUBE_MAPになるようです。
// あとは再利用するだけ。これはMRTではないので、その都度アタッチするテクスチャを切り替える必要があります。どのみちカメラは1つしかないので、
// まとめて...というのは無理なわけ。

レイマーチングとMRTを組み合わせれば方向を場合分けして...とかすればできるのでそういうやり方もあるでしょうね。
与えられたUVからどの方向にレイを飛ばすか決めて飛ばす方向に応じて描画先を変えればまとめて描画できる。ただこの場合
CUBE_MAPではないのでサンプリングは独自にロジックを作る必要があると思う。難しくなさそうではあるけれど。

とりあえずCUBE_MAPのテクスチャ使えるようにしましょ。

CUBE_MAPのフェッチ成功しました
wとhがundefinedになってるのを解消したら一発で出来ました
これからいろいろ検証していきます

TODO
で、あのー...boidsですが。
多分描画と同時更新のTFでフレームバッファに焼きつつ更新すれば、で、それ参照しながらにすれば、いけるんでない？
んでそのデータでインスタンシングするわけ。つまりフレームバッファをswapする代わりにattrをswapするのよ。
できるかなぁ。試してみよう。他の点が参照できないの不便なので。
それに位置と速度でふたつのダブルフレームバッファ用意するのも手間でしょう。
若干変則的なコードになりそうだが...

いずれ2D_ARRAYもできるようにするよ。面白そうだからね。

マルチレンダーターゲットですが、あれですね。使う場合はそれぞれのテクスチャがキューブマップになりますね。
つまりたとえば3枚であれば3枚ともキューブマップになるというわけ（3x6=18枚）
そしてレンダリングの際にはそれぞれについてframebufferTexture2Dで描画先のターゲットをいじる必要がある
たとえばxpなら1枚目のxp,2枚目のxp,3枚目のxp、といった感じですね。
ディファードレンダリングで動的キューブマッピングみたいなことができる可能性がある。その方が速いかは、知らんけど...

TODO
例の4000boxをMRTで書き直す。あれMRTじゃなかったんですね...個別に色を決めたい
流体
ブルーム
CUBE_MAPとフレームバッファ
TF＆インスタンシングでTF時にフレームバッファにデータを落とすことで他の頂点を参照しつつ位置や速度を更新
2D_ARRAYテクスチャ
2D_ARRAYテクスチャとフレームバッファ
（3Dテクスチャ）
（3Dテクスチャとフレームバッファ）
textureProjの扱いに慣れる（目指せ光学迷彩もどき）
以上
じゃないでしょ

ライティングシステムの整備。これが遅れている理由は、複数の状況に対応する必要があるからです。ほんとはですね、
たとえば単色や頂点色やテクスチャ、これ別々のshaderでやるべきなんですけどくっついてるので。フラグで切り替えるよりいいので。
動的生成です。shaderの動的生成。これをやりたい。attributeやuniformを必須/付加的で分ける。varyingも必須/付加的で分ける...
たとえばvVertexColorは付加的でしょう。そこらへん。頂点色。vTexCoordもテクスチャ彩色しないなら不要でしょ。そこらへんよ。
基本はノーマル？法線で色を付けるのがデフォルトで...
デフォルトは白一色でしょう。
デフォルトは白一色で、それをベースとしたうえでデフォルトのin,out,uniformを決める感じ。
さらにpositionやnormalをメソッドで動かせるようにする
全体の構成はバーテックスシェーダがin~~~uniform~~~out~~~~const~~~~必要な関数~~~メイン関数
メイン関数は頂点決定ステージ、法線決定ステージ、下処理、必要ならvertexColor,必要ならtexCoordをoutで送る準備で、
これを用意するのはそういうshaderを選んだ場合とする。
フラグメントシェーダについて...
uniform~~~~in~~~const~~~~out(MRTの場合は複数でlayout指定)~~~必要な関数~~~メイン関数
メイン関数のステージではマテリアルカラーをどうするかとそこにどうライティングを適用するかが問題となる
マテリアルカラーのデフォルトは白一色
それをどうするか。法線彩色？単色？頂点色？テクスチャ？キューブテクスチャ？いろいろ
それを加工する処理を加えるのかどうか、法線の情報でなんかするかも？そこをいじれるようにするなど。
それは作例を元に色々考えていく
具体的にはviewPositionとかvNormalとかそこらへん
ライティングをrgbに適用した後で何かしら処理を加えるのかどうかなど。それもメソッドとっかえひっかえでいいと思うし。
出力部分はデフォルトをfragColor=~~~~で用意しておくけどMRTなどの場合は丸ごと書き換えられるようにもする
その際にはそこで決まった色の変数の名前などを厳密に決めておく必要があるでしょうね
で
ライティングの設定をもっとわかりやすく、少なくともp5よりはわかりやすく
カメラとトランスフォームももっとわかりやすく...

これとは別にディファードのテンプレ、こっちはカメラしか使わない...ディファードはフォグや被写界深度やるのに使う
速いとかではない（本来）
これも部分的にいじれるようにしよう。おわり。

いつだって作例が方針を決める。
それを忘れないで。
作例が無ければどうしていいのかわからず途方に暮れることになる。
あの人見てれば分かるでしょ？ゲーミングほにゃらら。そういうことよ。（プルリク出してほったらかしを繰り返してる駄目な人）ああはなるまい。ああはなるまい...

プリミティブの用意で尻込みしてたでしょ
あれは要するに...
テクスチャ座標とかいろいろ、まあいいか...んー。
プリミティブも欲しいね...いずれね...立方体とかポンっと出すの難しいからね...
キューブマップ...法線...ううう
あとテクスチャでuTint掛けてるけどこれテクスチャ限定なの明らかに不自然だから
「プレステージ」で任意で追加する形にしよう。uniformとか独自追加して。だって要らんでしょう、基本。

環境マッピングできたので寝ます
gltfもう無理だと思う。やめよう
で、あっちは多分スケールでなんかミスしてる...

できた
できたけど
もう興味なくなった

normalMatrixを外で計算することにしました

TODO
さしあたり3つ
まずgltfのロードですけど
動かすことが目的なら必要なデータをピックアップしてjson化してそれを使えばいいので
そういう方向性もありだと思う
実際もうそれはできるわけだし
次にShaderSystemですが
RenderingSystemと改称して複数のShaderを扱えるようにする
そのうえで切り替えが可能に
ああいいや
ShaderPrototypeと改称したうえでRenderingSystemっていういわゆるコンポジットクラスを作ってそっちを使いましょう
で
forwardとdeferredはまとめてひとつにする
だってライティング部分が一緒なのにわけるのめんどくさいでしょう
そういうことでよろしく！！！

できました
ディファードはもうちょっとお待ちください

TODO
gltfの方でrotation情報から回転させたりtranslateの情報から平行移動させたりしたいです
せっかくライティングシステム出来たのでいろいろ実験したい
書き直したいです
具体的には
ピッキング
トランスフォームフィードバック
MRT
インスタンシング
インスタンシング＆トラフィー
とりあえずその辺
あと雑に立体描画するでもいいけど
パイプとシリンダーを追加したい
あとトーラスノット
そんな感じ
それとは別にブルームと流体をやらないといけない...

最新情報
例のフラミンゴはShapeKeyだそうです
とりあえず
単独メッシュと単独ShapeKeyくらいは対応できるようにしよう。

PBRの記事、リンク切れてる...
まあでもコードは残ってるし、自前で実装してみるか～

パフォーマンスチェッカー終わったよ。
さてと。
今やりたいこと
TODO （何回目やねん）
・インタラクション周りの整備。これしないとオビコンを始められないしピッキングも面倒だし流体をスマホで動かせない。
　mouseX,mouseYもいい加減こっちで取得できるようにしたい。独自に。要するにfoxIAですね。しかし...
　（ああmouseXとmouseYに相当するあれをスマホだと取得できないですね...パーティクルのとか。だから書き直すしかないと思う。
　まあmouseXとmouseYでやってることってイベントリスナー内でグローバルに代入してるだけなので、foxIAが整備されれば同じことできると思うよ。うん。
　んで(mouseX,mouseY)もしくはタッチポインタの(touch[0].x,touch[0].y)の最終履歴をあれする、とか...かなぁ？わからん。）
・カメラ周りの整備。いい加減オビコンのコピペをやめたい。邪魔。あとメソッドが死んでるのも本意じゃない。最終的にslerpまで全部実装したい。
　最初のセッティングが面倒なんですよ。だいたいオビコンのために2つカメラ用意するのがあほらしい。
・ディファードのテンプレートを作る
・gltfからメッシュとアニメーション、単独オンリーで実装。余裕があれば複数。目標はフラミンゴ。
・レンダリングシステムでの書き直し。MRT,ピッキング、TF,インスタンシング、インスタンシング＆TF,その辺。余裕があれば富士山。
・mebiusboxさんのコードでPBRを実装してみる
・（優先順位低）メッシュを増やす
・（優先順位中）ブルームと流体
・（優先順位低）transformExに状態の記録や状態の補間に関する処理を追加してみたい。Blenderのキーフレーム的な。
・（優先順位低）レイマーチングでキューブマップ作成、もしくはチュートリアルの続き（動的キューブとか）

foxIAいい感じなのでそのまま移植すればいいと思う
あとあの、CrossReferenceArrayあると便利かなぁって思ったりした（一時期多用してたやつ）
まあいいけど
カメラは何をしたいのかがすべてじゃないかと。やりたいことを満たしてくれる内容だけミニマムに定義して足していく。
一つ提案が...
今って10を対数の底にしてるんだけど、これ固定だと距離が違うときにカバーする長さが変わっちゃうから、
ニアとファーの対数の差が等しくなるようにしたらいいんじゃないかと。0.1と10でも0.5と2でも同じみたいな。
とにかく対数の底だけ可変にしたい。できればfar/nearの平方根にするとか。0.1と10だとこれが10なので。
あんま考えなくていいやすきにしよう

up周りの回転
上下方向は制限する（当然）
もしくはポインターの移動方向への回転
これらは切り替え可能にする
Cameraのslerp
これは独自実装した高速バージョンを使う
そんなところ。
でもblenderがクォータニオン使ってて
それ使って何かするかもしれないし
しないかもしれないね。
クォータニオンって回転しか扱えないからそこがちょっとね。カメラって回転だけじゃないし。

foxIAでパーティクル動かすか
できる？複数タッチに対応させたいのよ。単独じゃなくてね。
カメラ再整備するならあれ、ニアとファーを比率で扱うのやめたいです。普通にやればいい。

あとorthoはwidthとheight以外要らないですね。frustumも用意するならnearのところのwidthとheight以外は要らないですよね。
何が言いたいのか。だって要らんでしょう。orthoに必要なのは横幅と縦幅だけ。あとは、要らんでしょう。
p5のfrustum, あれの正体はですね。orthoのアホみたいな自由度をperspectiveに持ち込んだんですよね。
じゃあその自由度に何かメリットがあるかって言ったら...
ないです
というか、あることを示すスケッチを知らないです。あるんですか？？？
perspectiveがfovとaspectの2変数で定義されるならorthoも2変数でいいと思うのね
どっちも正でいいと思うし。
その方が圧倒的に分かりやすいと思うのね。frustumもnearのところのwidthとheightからfovとaspectを計算する仕様でいいと思います。
実質perspectiveと一緒
というかperspectiveの仕様策定方法の一つにしちゃえばいいと思うのね
...要らないか。なくしちゃうか...Threeどうしてるんだろ...とか。まあ、いいか。
射影行列もビュー行列も作り方はもうわかってるのです
だから簡単だと思う
クラス定義？んー。
ortho/perspectiveの切り替えをしたい。
まあどうしたってcenterの概念は必要だろうから、centerのところでやればいいと思う。おそらくBlenderもそんな感じでやってる...はず。
center無いとオビコン作れないし。ね。
こうすればviewとprojが完全に切り離されるね。よしよし。切り離せないとprojだけいじるってことができないから不便なのですよ。

orthoの拡大縮小でprojいじったけど
さっきチェックしたけどおそらくblenderのorthoの拡縮はprojしかいじってないですね。自分もそれが合理的だと思ったんですけど。
距離はいじってない
んー...でも近づけてからpersに戻すと距離が縮んでるので距離は縮んでるようです
わからんー
今ortho使ってないけどね...まあいいか。えーと。

カメラ
centerは用意します
centerだけです。orbitControlはカメラを引数に取ります。カメラをセットしておくとリスナーが...カメラの関数を呼び出す形。
topとcielを両方用意してcielを基準としてある程度の角度までしか動かないようにできる。
あるいはfeeeRotationで回転させる。これだとその辺の心配が不要。freeRotationはcielを同じように回転させる必要があって、
それにより途中で相互に切り替えたりできる。切り替えというかできないと不自然だからそうするだけ。
動かし方は基本ひとつのコード内で変えたりしないけど整合性ないと不自然なので。

perspectiveがデフォルトでnearとfarでfovとaspectは固定でzoom
zoomというかオビコンのマウスホイールの挙動について
対数ベースの挙動にこだわってきたんですがやっぱ不要だろうと
うん。一気に飛び出しちゃうのやっぱ普通に不便だわ
frontと逆方向、もしくはfront方向に普通に移動するメソッドでいいと思う。んで移動のファクターを手動でシーンに応じて設定すればいい。
これが本来のdolly. だからdollyとzoomを区別する。もうやってるけど。それを...もうやってる？？？
あとnearとfarを比率で扱うのはやめましょう。これは駄目ですね。そこが一番大きな変化。
orthoで色々用意するのもやめます。上下で混乱するのもそうですが、自由度がそもそも要らないので。frustumも廃止します。
orthoの情報なんて横幅と縦幅だけでいいので。あと相互に切り替えたいので全部持たせる形で。切り替えるときに互いのパラメータをフィットさせる。
pers→orthoではcenterで長方形を切り取ってそこの大きさにする
ortho→persのときはcenterのところの長方形でfovとaspectが変化しないように必要に応じて距離も変化させる
って思ったけど
やっぱfovとaspectを変化させた方がいいでしょうね。距離が変化するのは不自然でしょう。そもそもorthoで拡縮するのがレアケースだし。

topとcielがあってわけわからんのだけど...topでいいじゃん？？？？
eyeでしょ、centerがあって、それによりfrontが決まって、...upは上方向、それによりside,frontとsideから...あー。なるほど。
やっぱそれでいいじゃん？upを再計算して正しいupにする。それとは別にtopをupのコピーとして用意してオビコンの際の基準にする。それでいいと思う。
んでfreeRotationの場合topも含めて4つとも回転させればいい。

topとcielが分かれている理由がわかりました。topをresetする際の記録用です。あほか。
要らんね...
戻したいならセッティングをいい感じにまとめておいてそれを使って戻す方法があると思う
persならnear,far,fov,aspect
orthoならnear,far,width,height
viewに関してはeye,center,upから復元できる(topはそのときのupでリセットされる形)
なのでこれらのデータをひとまとめにしてstateとし、
state -
  near, far,
  pers - fov, aspect
  ortho - width, height
  view - eye, center, up
で。これをまとめて、追加パラメータでpers/orthoを選ぶ。orthoの場合はeyeはそのままでwidthとheightを...
orthoのデータ不要かも
eyeとcenterの距離とfovから横と縦を計算してorthoデータとすればいいと思う。
あとblenderは普通にcenter使ってるはず。じゃないとテンキーのあれができないはずだから。OK....
もしくは複数のstateに対して補間されたstateを計算するとかそういうのが必要になってきそう。
その場合、もしorthoについてはpersから自動的に計算するのであれば、persとみなして補間されたstateを計算してそれをortho化するのもありかも。
persの補間だと射影行列が出てこないので楽ができる。？？？
いや射影...
まあそうね。
...
補間についてですが。うーん。fovとaspectは線形補間するとして。うーん。nearとfarも？？そうね。
カメラがorthoの場合はfovとaspectの代わりにwidthとheightを使っているのでそっちを線形補間する。とにかく途中の行列を計算する。
orthoの場合は

state記録時にpersならorthoのデータをそのときにorthoに変換した場合の計算値として用意しorthoであればその逆を実行する
逆についてはcenterを動かすかどうかが問題なんだけどよく考えたら相互の切り替えすること自体が稀だし...
persをorthoにする場合にwidthとheightをfovとaspectから計算するでしょう。ならその逆も無いとおかしいわけ。
orthoのwidthとheight,それにeyeとcenterの情報からfovとaspectが再計算されるということ。
centerを動かすとクリップの関係でいろいろおかしなことになりそうだし、その方がいいと思う。そうしよう。よし。
オビコンの拡縮は平行移動のdollyにする。その方が自然。スケールに応じて設定すれば問題ない。よし。
よし。

// 生成するときにpersがデフォですがtype:orthoとすることでorthoとして用意されます
// typeが未定義の場合はpersです
// その場合はortho:{w:~~, h:~~}とする...pers:{fov:~~,aspect:~~}とかする。
// persかorthoかに従って他方のデータが用意される
// めんどうだな
// たとえば proj: { near:~~, far:~~, type:"pers", fov:~~, aspect:~~ } とか？そういうの。
// もしくは proj: { near:~~, far:~~, type:"ortho", width:~~, height:~~ } とかそういうの。

// 常に問題とされるのはデータのいじり方。これに尽きる。
// viewに関するデータをいじってもpersには影響ないし、逆もしかり。独立しているので。
// これで。
class Camera2{
  constructor(options = {}){
    this.view = {}; // eye, center, top, side, front, up
    this.viewMat = new Mat4();
    this.proj = {}; // type, near, far, fov, aspect, width, height
    this.projMat = new Mat4();
    this.states = {}; // stateをキーで記録。内容はeye,center,top,near,far,fov,aspect,width,height(, viewMat, projMat).
    // 行列計算するのめんどくさいでしょ...含めた方がいいかもしれない。slerpのためにもあった方がよいかと。
    this.initialize(options);
  }
  initialize(options = {}){
    // wとhからaspectなどのデフォルトデータを設定する。
    // wとhのデフォルトはキャンバスの横と縦
    // eyeのデフォは真上、h/2のsert(3)倍
    // centerのデフォは中心
    // topのデフォは0,1,0
    // nearとfarはeyeとcenterの距離の0.1倍と10倍
    // fovのデフォはPI/3
    // aspectはw/hで計算する
    // ortho用のwとhも問題なければそのまま使う
    // typeのデフォはpers
    // 以上。
    // 一通り用意できたら行列を計算する。おわり。
  }
  // メソッドに関してはほぼ全部移植でいいと思う
  // nearとfarを比率ではなく実数値にしたので
  // それについての変更が色々あると思う
}

getViewPosition(p)
pはグローバルポジション。これのビュー座標を出すための関数。
getNDC(p)
pはグローバルポジション。これの正規化デバイス座標系を出すための関数。
getViewPositionFromNDC(x, y, z=1, centerBased=false)
NDCに対してそれをもつビュー座標を求める関数
基本的にzが1のときの物が算出される
引数のzは視点との距離
persとかならそのままこれを全体に掛ければいいんだけどorthoでそれやるとまずいことになるので
orthoの場合はcenterBasedをtrueにしてz成分にその値を当てはめる方法を取っている
しかしdistanceは廃止する予定なのでその場で計算する必要があるかもしくは何らかの変更が必要になりそう。
centerBasedっていうのはcenter基準という意味で、これの場合、1なら中心のところ、という意味になるみたい。
x,y,距離 と x,y,1,trueが同じ第3引数を与える。
getGlobalPositionFromNDC(x,y,z=1,centerBased=false)
NDCからグローバル座標まで持っていく。
getParallelPosition(p,x,y)
グローバルのpに対して正規化デバイス座標がx,yであるようなグローバルの点qを返す
たとえば画面ベースで平行にオブジェクトを動かすときに非常に重宝する関数
p5のオビコンではこれを一部改変したものが使われたようです


/*
射影について補足
typeがpersの場合widthとheightは明示されていなければ自動的にデフォの
typeがorthoの場合fovとaspectが明示されてなければ自動的に...
*/

拡大縮小は対数でいいよ
もうどうでもいいよ
ぜんぶどうでもいい
はやくオビコン作って
いそげ
ホイールの挙動は中心との
でいいよ
Threeも対数ベース（掛け算仕様）だって
だからもうそれでいいです

pers()
ortho()
perseToOrtho(), orthoToPers()
そこらへん
getProjMat()
getViewMat()
dollyIn(), dollyOut() これ分けてるのは分かりやすくするためですね（Threeが分けてた）

オビコンでやること
回転
横方向はtopの周りに回転する。上下方向は制限する。ぐるぐるさせない。topは不変。
freeRotationはポインタの移動方向にしたがって全部回転させる
平行移動
マウスの動いた場所に向かって動く感じにする（例のイージングで）
メソッド的にはmoveになるかと。射影行列を使う。移動距離だけ算出してあとははめこむだけ。
拡大縮小
中心との距離を対数ベースで変化させるdolly処理。

カメラはperspectiveとorthoを分けることにします。
それはそれとして

テンプレートちょっといじりました
まずlightOn/Offについてその場でuniformをsetするようにする。これで_nodeを引数に取る形。
...nodeで生成すれば引数要らないんだよなー。どうするかな。まあ
難しいんだけど
複数のnodeを使うケースが稀だからそれでもいいと思うんだけど。
あとrenderをやめてrenderPrepareにしました。これはやはりインスタンシングとかTFインスタとかドローコールの柔軟性が
求められる場合に対応できないのでそこら辺ですね。
あとインスタンシングとかでdivisorなど必要な場合にregistMeshが対応してなかったので修正しました
textBandsをその筋で書き換えました。以上です。

上げないけどね。求められて、無いから。

雑にfoxIAぶちこんだ
更新については逐次でいいと思う。分かりやすいように分けといたから。
foxIAはどっちでも使えるのでね。個別開発ですね。

renderPrepareですが、わけたほうがいいかと。独立させ...というか
_nodeの関数？にするとか。...
ああなるほど
setUniformか
そうね...uniformの種類...やめよう。うん。
copyPainterがそうなってるのもそういう理由からです。
旧RenderNodeはその辺あんま気にしてなかったんだけどね。

nodeを渡しましょう
問題ないと思います
複数のnodeを扱う場合であってもそれらが同じことをする場合であっても
別々に用意した方が混乱も少ないでしょう
渡します
いろいろ変更しないといけないが...
終わりました
ごめんなさいね。これで一応固定されるはずです。問題なければ。
いい加減書き直したいんですよね...メッシュもあれ直方体にしたりディテール導入したいのです

メッシュの取得をパラメータ式にしたい。引数式だとごちゃごちゃしてしまう。
今現在あそこからメッシュを取得してるコードが3つくらいしかないので
今取り組まないとp5と同じようなことになってしまう
円柱とか
ね。今のうちに。
変数名も統一して...

getMesh(文字列、パラメータ)で統一しましょう。あとは内部関数で隠蔽しましょう。
cube
sizeとdetailだけ。x,y,z全部一緒。boxを用意して、その派生でいいと思う。
box.
sizeのx,y,z, detailのx,y,z
sphere.
sizeのx,y,z, detailのxとyが分かりやすそう。xが水平でyが縦。
torus
aとbでdetailのaとbの方が分かりやすいのでは？たとえばdetailのaは大きい半径の方のディテール。
plane
sizeのx,y. detailのxとyですね。
何か欲しい？欲しいならいろいろ用意しよう。円柱とか。

IBOを複数用意するとか。ワイヤーフレームも欲しい場合とかに対応させたい。
otherIndices=[{name:~~~, data:~~~}]でname+"IBO"で{data:}で、みたいな？
large:trueは65535を超えたらってことで。

そこら辺のテストが必要ですね
つまり複数IBOをやらないといけないわけです
がんばれ～～～
線出来たけど
まあそうね難しいわね
複数IBOは出来ました
lineについては
オプションで用意する...まあいいか。lも追加で。って思ったけど
モデルデータの場合は用意できないわけで
まあいいか
個別にしよう
それかモデルデータの場合は用意しなくていい。以上です。

foxIAについて問題が発生したので一旦切り離します

問題が解決しそうです
まずtouchについてですがpageX,pageYだとキャンバスベースの値にならないのでキャンバスのleftとtopが必要で
加えてtouchMoveでpreventDefaultしてしまうとキャンバス外のタッチで画面が動かなくなるのでそれを防がないといけない
あとresizeでIAとpointerのあれこれが更新されないといけないのでそこら辺ですね
おわりました。おつかれさまでした。

だめでした
マウスもか....
キャンバスの外に出るとだめですね。
マウスについても同様に計算しましょ
wheelをcanvas指定にしました。

Vec3にslerpを導入しました
クォータニオン？

何もやりたくない
です

海で泳ぐの楽しかったですまた行きたいです

registMeshで{otherAttrs:[], otherIndices:[]}
これで線などの別のIBOも登録できるようになりました。
メッシュにlineを導入
メッシュシステム
あくまでもテスト用です。複雑な形状はどうしたってモデリングソフトで作るしかないので。簡易的なプリミティブ用です。
v,n,uv,fのほか、オプションでline付けるだけ。そんだけ。んー...
getMesh(文字列, {
  cubeの場合。size:1辺の長さの半分（±1なので）。detail:分ける数（1でデフォルト）
  boxはsizeとdetailがx,y,zのベクトルになってる
  sphereはsize:半径でdetailはxとyです、xは横、yは縦のdetail
  ellipsoidはsizeがx,y,zでdetailについては一緒です。ひねりはありません。
  torusはaとbでaが長い半径でbが短い筒の方の半径でdetailもそれに応じてaとbで指定する
  torusKnotも一緒でいいかな。ひねりの加え方も指定してください。pとqだったはず。
  planeはxy平面平行でsizeとdetailはxとy
  cylinderはz軸に平行で半径rとbottomとtopを指定する（大小逆の場合は反転させる）、デフォルトは-1と1で半径も1です。detailはxとyで指定、xが横でyが縦。
  coneは底面がxy平面に平行です。detailは一つだけです。半径rと高さhを指定します。
  tubeは若干ややこしいです。閉曲線の方程式を放り込みます。微分可能な周期的3次元曲線の式です。これを使って用意します。detailはxとyでyが曲線方向です。半径も指定します。
  いくつかが採用されて実装されます
  icosahedron,octahedron,dodecahedronも実装予定です。detailも指定します。多分。（三角形を分割する）
  いずれの場合も、wireFrameがtrueだとlの形でlineも提供されます。内容的にはすべての線、です。なので立方体で
  ああいうことしたい場合は独自に用意してね...
});

wireFrameに変更
wireFrameのオプションを廃止

カメラって何？
行列です
行列を提供する機構です。そして行列をいじるのがいわゆるカメラメソッドです。
perspectiveとorthoの違いは？射影行列です。射影行列が違います。
ビュー行列はそのままです。またtfについてはトランスフォームという形で分けています。これも面倒で、一律適用です。当たり前だ。uniformっていうのはそういうこと。
つまりビュー行列と射影行列を提供する機構ならカメラということです。以上。
それを定義するのに何が必要かっていうのがコンストラクタ。どうしましょ。
カメラの基本クラス

_nodeを渡す必要があるかどうか。ある？てか使う？んー...

eyeとcenterとtopをベクトルで定義。これらは常に必要だと思う。そこからfront(z軸)とside(x軸)とup(y軸)が用意される。
これら6種類のパラメータは常に保持され、viewParameter群と呼ばれる。
class CameraPrototype{
  constructor(viewData = {}){
    this.viewMat = new Mat4();
    this.projMat = new Mat4();
    this.view = {};
    this.proj = {};
    this.setView(viewData);
    this.states = {}; // stateを記録して、自由にロードしたり、補間したり、取り出して他のカメラにコピーしたり、自由自在。
  }
  setView(data){
    // eyeのデフォルトは画面のサイズの縦半分のsqrt(3)倍でいいと思う
    // centerは(0,0,0)でtopは(0,1,0)でいいと思う。配列で定義する。
    // そこからメソッドでfront,side,upを計算して...OK.
  }
  calcViewMat(){
    // eye,center,topがはっきりしている状況でfront,side,upを計算して行列を作る処理
    // その際平行移動が要るのでeyeとcenterの情報はもちろん必要になります
  }
  calcProjMat(){
    // 継承でいろいろ
  }
  copy(){
    // 必須。
  }
  setState(name){
    // nameでstateを記録。
  }
  loadState(name){
    // 記録したstateに移す。その瞬間に移す。
  }
  lerpState(fromStateName, toStateName, amt){
    // fromとtoをamtでlerpする形。事前の射影をいじる処理を個別に用意する。
    // そこから先は共通の処理とする。
  }
}

class PerspectiveCamera extends CameraPrototype{
  constructor(viewData = {}){
    super(viewData);
  }
  calcProjMat(){
    // nearとfarとfovとaspectで定義する
    // fovはPI/3がデフォルト、aspectは未定義の場合全体に対してw/hでOK
  }
}

class OrthographicCamera extends CameraPrototype{
  constrcutor(viewData = {}){
    super(viewData);
  }
  calcProjMat(){
    // nearとfarとwidthとheightで定義する（leftとかそういうことはしないです）
    // persと違ってnearとfarは負の数が取れる（らしい）（距離の概念が無いので）
    // たとえば例のアニメ作る際に近づけても全体が入るようにnearを大きい負の数に取るとかするといい
  }
}

// blenderのorthoのオビコンはシーン全体が入るようにNearとFarがいじられているので、
// 拡縮の際にカメラを近づけてもシーンからクリップされることはないようです。
// persだと普通にクリップされるけどね。そういうことか。

orbitControlに落とす場合、まず移動メソッドはmoveを用意してそれを適用する。
各段階でそれをやる、減衰を定義して...カメラごとに速度を用意して減衰させる。名前で登録して個別に管理する。一度にコントロールできるのは
ひとつだけ。拡大縮小は中心との距離をいじるだけだが、orthoの場合は射影行列というかwとhもいじる形。
回転はtopの周りに回転する"normal"と自由に回転する"free"の2種類を用意する。"normal"の場合は上下に制限を付ける。
制限はオプションでいじることができる。foxIAのInteractionの派生。

カメラの回転はnormalの場合はあれはspinとangleですね。angle...ハイアングルとかローアングルっていうらしいから。俯瞰とあおりを実現する動き。
freeの場合はrotateでいいと思う。ある軸の周りにカメラのすべての軸を回転させる。
拡大縮小はdollyでいいと思う。正の数で離れる感じ。
移動はmove. p5のオビコンはメソッド一切使ってないけど、まあ、ありえないです。メソッドでやりましょ（おいっ）
普通に馬鹿げてるわ。

_timer使えばresetに関する処理は全部できる。カメラに持たせればいい。というか、遷移ね。
すぐには廃止しない
どうせカメラ新しくする際に全部見直すのでそのときに一緒に消し飛ばせばいいんだわ
registMeshそんな使ってないけどね

法線の求め方ですね。UnionFindを使うのがいいと思います。
まずマージするという考え方を捨てる。頂点情報はいじらなくていい。そのまま、たとえばソートする。で、
たとえばx成分だけの配列を作ってソートする。それでたとえば差が0.001未満だとかそういうのに絞って距離を測って
閾値以下だったらユニオンを作ってファインドする。これで頂点のUnionFind配列とする。
これに基づいてfaceの方の配列をいじる。新しく作る...で、それと元の頂点のあれから法線を計算してnに放り込んでやる。
で、抜けてる箇所が出てくるのでそこは要するにルートでは無いので、ルートまでさかのぼって内容をパクる。
これで完全に正しくなるはず。
もしくは新しく作る必要ないかも。fの方？逐一...それ以前に...あー、駄目か。同じじゃないと駄目だ。
だからいちいちユニオンファインドしてルートに置き換えて計算すればいいと思う。
マージで頂点減らしちゃうとどうしてもUVの問題が出てくるからね。この方がいいんじゃないかな。
まあ、めんどうだからさしあたりやらないけど...

calcNormalだけあっても仕方ないんだよな。UVと共存できないんじゃどうしようもないんだわ。
頂点データだけ用意すればいいっていうのは簡便で楽ちんでうれしいけど、UVがおろそかになるんじゃだめでしょう。とはいえまあ、一応用意するけどね。
要するに頂点マージに関するUnionFind配列を用意するでしょ、で、calcNormalでfを走査する際に各頂点のインデックスをマージ先で置き換えるだろ。
それについて計算して、該当する番号に重み付きで法線を足していくってわけよ。
それが終わったらnについてルートでない場合にルートの法線情報で置き換えていく感じですね。パスコンは終わってるものとします。
そういう事情から、もし仮にそれを想定しない単純な法線計算関数を用意した場合、UVを無視するこんな関数要らないってなってまるごと破棄される
可能性があるんで、迂闊に用意できない、もっとも内容的にほぼ一緒なのでとりあえず用意しておくことは無駄ではないと思います。

マージをオプションにすれば改変する必要なくなるよ、というお話。

this.merge = []
とかする。mergeという関数でここにUnionFind配列を入れるのだ。んでさ。calcNormalは普通に用意する。mergeDataが[]でない、つまり
存在する場合に、これを用いるかどうかオプションで、オプションで決めて、使うのであれば使う。で、
useMerge = (this.merge.length > 0 && options.useMerge);
使うのであれば、faceの走査の際にrootを使う。rootに法線をためていく。終わったらrootでないものをUnionFindデータの走査で
割り出してrootの内容をコピーする。最後の処理は一緒。これなら法線計算の関数を普通に用意するだけで済む。加えて、
頂点を改変するたびにいちいちマージし直す必要もなくなる。同じデータを使いまわすことができる。

さてと。まあそれはおいおい実装します。とりあえずGeometryのcalcNormalを用意しました。OK!

LSですが、今現在の使い方
まず LS = new ex.StandardLightingSystem(_node);
ノードで初期化
次にLS.initialize()
ここでたとえばtexCoordを使いたいならLS.initialize({forwardLight:{useTexCoord:true}});とかする
addUniformやaddAttrやaddCodeで適当にカスタマイズ
registPainterで登録（引数はpainterの名前だけ）
使うには登録した時の名前でいつものようにusePainterもしくはuseする
LS.setLightやLS.setDirectionalLightなどでライトの設定
setLightingUniforms()でライト関連のユニフォーム
で
いじりたいのはここです。renderPrepareです。これ不自然なんですよ
問題は_tfと_camですね、これがグローバルなのです。困るわけ。
それにrenderPrepareっていう名称もなんか不自然でしょ。これ内容はtransformでしょう。
というわけで
まあ、大規模にいじらせてもらいます。

this.camSlot = {};
this.tfSlot = {};
this.curCam = undefined;
this.curTf = undefined;
そして初期化時に"default"という名前のキーで自動的にデフォルトのカメラとTFが用意されます
カメラはキャンバスサイズに合わせたパースペクティブのやつです
TFはただのTFの元のやつです
で、切り替えと登録の関数を用意するわけ
呼び出し自由にできるように
registCam(name, cam)
registTf(name, tf)
setCam(name)
setTf(name)
defaultしか使わないのであればこれらの処理は一切不要です（defaultとして別のものを使いたい場合は"default"で上書き可能です
で
renderPrepareは廃止します
代わりにviewとtransformを用意します
これらは現在使われているカメラとトランスフォームへの操作を実行するものです
配列しか渡さない
もっというと配列である必要がない？か。引数列挙でいいと思う
/*
function setup() {
  createCanvas(400, 400);
  // (10) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
  testFunc(0,1,2,3,4,5,6,7,8,9);
}
function draw() {
  background(220);
}
function testFunc(...args){
  console.log(args);
}
*/
これ使えばいい。配列記号で囲む必要はないのだ。
transform(...commands)
view(...commands)
これでいいのだ。で、今までrenderPrepare()、まあ、廃止です。renderPrepareは廃止。また昔のコードが動かなくなるね。残念～。
だから書き換えるのしぶってるのよ。後々面倒だから。（forkした人のコードが動かなくなる？知らん、自己責任でしょ。）
代わりにsetMatrixUniforms()で引数無しで呼び出す。なぜなら使われているcamとtfが使われるため。
ついでにsetCommonUniforms()を用意して、まとめて実行できるようにする。tfもcamもひとつしか使わない場合限定だが、
2回呼び出す手間を省くことができるでしょう。useのようなものですね。usePainterとdrawFigureをあわせもつuse,
setLightingUniformsとsetMatrixUniformsをあわせもつsetCommonUniforms.
ついでにMeshSystemとShaderSystemにuseを用意してそれぞれusePainterとdrawFigureが実行されるようにします。
いちいち_nodeで書く必要がなくなります...まあ個別にやる場合もuseを使いたいってだけの話。
あとあれ
PerformanceCheckerにhelpって関数用意したい
やめよ
UserInfoってクラスを用意しましょ
ex.UserInfo.copyPainter = `つかいかた`;
ex.UserInfo.PerformanceChecker = `つかいかた`;
まとめよう。個別に書くのクッソ面倒

"clear"でtfをinitializeする的な？
resetMatrix()に相当する。
LS.transform("clear", {t:[100,0,0]}, {rx:t*0.3*PI}, {ry:t*0.5*PI});
_node.bindIBO("torusfaceIBO").drawElements("triangles");
LS.use("line"); // _node.usePainter("line"); だとめんどうなのでuseで切り替えられるようにする
_node.bindIBO("toruslineIBO").drawElements("lines");
どのみち大量のオブジェクトでこれをやりたいなら
インスタンシングの方が速いよね
10とか20ならともかく
1000とかだったらドローコールでやるのは非現実的でしょう
線描画にしても
同じこと
...

うーん。

TODO
線描画用のshader、ライトのクラス化、ヘルパーの導入（shaderの追加）
ヘルパーの描画は別描画にすべきだからね。

実行は現行のカメラを新しくしてからにしよう。

TODO
ロードマップ
1. カメラを新しくする（オビコンまで一通り整える）
2. renderPrepareを廃止して今提案した形で書き換える
3. （急遽追加）meshUtilをクラス化して_nodeとmeshを持たせるようにしregistの引数を名前と追加データだけにする
4. getNormalsなどのモデル系関数をすべて廃止してmeshUtilに統一する。フレネ・セレについては個別に関数を用意して供用する。
5. 過去のコードいくつか書き換えて動くようにする
って感じ。

3.にboxとかね。(params, false/true)でやる感じ。isCopyはデフォルトfalseで、falseの場合は
MeshUtilではなくMeshSystemとかするといいかも。で、falseの場合はthis.meshをいじってその内容にしてreturn thisする。
trueの場合はthis.meshはいじらない。新しくその内容のmeshを作り、それを返す。そうすれば円柱を円で作ったりできる。
initializeで初期化する。しなくてもいいかもしれないが。compositeも用意し、this.mesh.composite(otherGeometry)とかする。
transformをGeometryクラスに用意する。内容はtransform(...commands)で、引数の配列の順にいろんなあれを...{t:[0,0,100]}とか
{rx:PI*0.3}とかそういうの。順繰りに適用する。MeshSystemにもtransformを用意し、this.meshに適用する。

TODO まとめ
meshUtilを廃止してMeshSystemという形にする。nodeとmeshを持たせる。メッシュ作製関数はmeshの内容をそれで置き換えるか、
そこで作ったメッシュを出力するかをfalse/trueで分岐させる。registは名前と追加Attr/Indicesだけ指定する。
LSのrenderPrepareも廃止で、transformとviewにして順繰りにメソッドを適用する形にする。
tfとcamを登録制にしてカレントが使われるようにする。
setLightingUniforms, setMatrixUniforms, setCommonUniforms.

registMeshの柔軟性が無いですね
他のプロパティが欲しい場合にこれじゃ何にもできませんね
transformFeedbackとかoutIndex使ってattrのswapとかしたい場合に不便
なので_node.registFigure(~~~)の~~~を作る関数と。。。
MeshSystemの中にあれする
this.meshData = {
  attrs:{
    aPosition:{size:3, data:[]},
    aNormal:{size:3, data:[]},
    aTexCooord:{size:2, data:[]}
  },
  indices:{
    face:{data:[]},
    line:{data:[]}
  }
}
メッシュのコンポジットなどの際にこれらの内容を更新する処理を実行する感じですが...難しいわね。
そんでaddAttrData,addIndicesDataでもって
addAttrData("aPosition", {outIndex:0});
とかそういうの。無かったら追加する。
addAttrData("aOffsetPosition", {size:3, data:[], divisor:8});
無かったら新しく作成される感じ
あったら普通に追加/上書きされる感じ
registの際はそのデータがそのまま使われるようにすればいい
これで問題ないはず

this.meshData = {
  attrs:{
    aPosition:{use:true, size:3, data:this.v},
    aNormal:{use:true, size:3, data:this.n},
    aTexCooord:{use:true, size:2, data:this.uv}
  },
  indices:{
    face:{use:true, data:this.f}, // faceIBO
    line:{use:false, data:this.l}  // lineIBO lineはデフォルトをfalseにしよう。追加するものは全部基本trueでスタートさせる、まあ当然だけど。
  }
}
こうすれば自動的に更新されていきます
外部から導入する場合も配列のポインタだけ渡しておけば勝手に更新されていきます
そんな感じですね
初期化時に不要なあれをクリアする必要があるので
そこは例のあれでfalseを指定した場合にinitialize()で追加したものをすべて破棄するといい
破棄しない場合は新しく作成される感じ
use:true/falseで登録するかどうか決める感じ。たとえば線描画しない場合など。
それでIBOの名前ですが
登録時に名前を使うので
名前 + face/line + IBO
これでいい
_node.bindIBO("torus2faceIBO").drawElements("triangles");
ノードが返るようにしないと不便でしょう。
drawElementsInstancedとかも使いたいし。

registDataの内容はメッシュ作成関数をfalseで呼び出す際に初期化される。
compositeで使われるのはこれら5種類だけなのでそれについても問題ない。
trueで呼び出す場合はそのメッシュが変えるだけでdataは変更なし。
同じことを2回も書きたくないんで。
また、独自にthis.vやthis.fを定義する従来の、いわゆる「p5.Geometry的な使い方」をすることもできます。
getMesh()でMeshSystemから登録されているメッシュを取り出していじるだけなので楽ちん。

// 三角形描画のアウトライン（想定）
LS = new StandardLightingSystem(_node); // この時点で自動的にtransformとcameraがdefaultで用意される感じ
LS.initialize();
MS = new MeshSystem(_node);
const mesh = MS.getMesh();
mesh.v.push(0,0,0,100,0,0,0,100,0);
mesh.f.push(0,1,2);
mesh.l.push(0,1,1,2,2,0);
mesh.uv.push(0,1,1,1,0,0); // 使わないけど。
mesh.n.push(0,0,1,0,0,1,0,0,1); もしくは mesh.calcNormal()
MS.regist("myMesh");
MS.use("myMesh");LS.use("lights");
LS.setLight({useSpecular:true});
LS.setDirectionalLight({count:1, direction:[0,0,-1], specularColor:[0,0,1]});
/**
  ここで動かしたい場合はたとえば
  LS.transform({},{},{},~~~);
  LS.view({},{},{},~~~);
  のようにする。モデルを動かすか、カメラを動かす。これらは異なる、だって複数のカメラで描画したりするでしょう。
  orbitControlにカメラが登録してある場合はそれが...
  同じカメラが使われるようにするの面倒か？どうしようね。
  多分その場合は
  const cam = LS.getCam("default");
  OC.regist("default", cam);
  とかする。こうすると...
  もしくは？
  LS.bindOrbitControl(OC);
  これによりLSとOCが連携されて、LS側でカメラを変えた際にOCの操作するカメラも変更される。LSでカメラを追加した際に
  OCにも同じ名前でカメラが追加される。LS.registCam("tuika", camTuika); -> OC.registCam("tuika", camTuika);
  OCの方ではカメラにタイマーが付随しててslerpなどの際に利用される...かもしれない。
  LS.setCam("tuika"); -> OC.setCam("tuika"); -> OCで操作するカメラも描画用のカメラも"tuika"になる
  そんな感じですね
  関係ないけどTfの方もstateとかstateの補間とかしたいわね。Tfにタイマーを持たせて遷移させるなどなどなどなど.....
 */
LS.setCommonUniforms();
_node.setUniform("uMaterialFlag", 0).setUniform("uMonoColor", [0.5,1,0.5,1]);
_node.bindIBO("myMeshfaceIBO").drawElements("triangles").bindIBO("myMeshlineIBO").drawElements("lines");
_node.unbind().flush();

などなど
だってメッシュ作成関数でやってるのがそれだから。ただしv,n,uv,f,lは固定です。faceとlineも固定。
vcとか欲しかったらwriteAttrで追加すればいい。lが気に入らない場合に上書きするのも自由。
追加attrも追加indicesも自由。それでregistすればすべて然るべく実行されます。
それもできるようにinitialize()を用意します。

writeAttr("aPosition", {outIndex:0});
writeAttr("aColor", {outIndex:1});
writeAttr("aOffsetPosition", {size:3, data:[~~~], divisor:8});
writeIndices("line", {use:false});
writeIndices("line2", {data:~~~});
新規追加する際に自動的にuse:trueが付与される
付与した後で変更できる
使わない場合はオフにできるわけ

結局今の{otherIndices:~~~~~~~}
めんどくさい。わけです。やめたい。

要するに
今ってUV使ってないじゃん
環境マッピングにハマってるし
線描画もやってないし
だから基本VNFでいいのよ
setFormat("V N F")
もしくはinitialize("V N F")でいいわけ
んで

// Geometry -> Meshに改名。もうMeshでいいでしょ。
// format = {attrs:{v:{name:"aPosition",size:3},n:{name:"aNormal",size:3},uv:{name:"aTexCoord",size:2}},
// indices:{f:{name:"face"},l:{data:{name:"line"}}}};
class Mesh{
  constructor(){
    this.attrs = {};
    this.indices = {};
  }
  initialize(format){
    for(const key of Object.keys(format.attrs)){
      const attr = format[key];
      // keyとnameは別。keyはvとかuvのようなもの。nameはaPositionなど、shaderで使われる名前。
      this.attrs[key] = {};
      this.attrs[key].name = attr.name;
      this.attrs[key].size = attr.size;
      this.attrs[key].data = [];
    }
    for(const key of Object.keys(format.indices)){
      const ids = format[key];
      // nameも一応用意しといて。
      this.indices[key] = {};
      this.indices[key].name = ids.name; // たとえばfaceの場合あとで「メッシュ名 + name + IBO」ってやるね
      this.indices[key].data = [];
    }
  }
}
で？
const v = this.attrs.v.data;
const f = this.indices.f.data
とかするの？めんどくさいね。めんどくさ...今のシステムでいいじゃんってなってしまう。

備え付けを使うならV N T F Lのうちいくつかでいいと思うんよね
たとえばヘルパーとかならV Lでいいでしょ
initialize("V L");
こうするとVとLしか用意されない
で
addAttrs("v", [1,2,3])
this.attrsのv...
this.attrs["v"].data.push(1,2,3);
addIndices("f", [4,5,6]);
this.indices["f"].data.push(4,5,6);
ただしたとえば
this.indices["f"] === undefined
の場合は何もしない
たとえばuvがなければscaleUVとかも何にもしない
translateUVとか
vとかuvはメッシュのデフォルト作成用のコードネームというかいわゆるプリセットです
デフォルトフォーマットはVNFを想定しています
なぜかというと
基本テクスチャ使わないでしょ
色が欲しい場合
たとえばですねこっちで
フォーマットに
まあその
C: {vc:{name:"aColor", size:4}}
とかあってですね
VNCFだとですねCが用意される
こっちで追加するのも
addAttrs("vc",[1,1,1,1]);
とかできるわけ
v,n,uv,vc,f,lまでは予めV,N,T,C,F,Lで呼び出せる形
全部使うならVNTCFLってなるけど基本的にはVNFでいいと思うんよ
Lですが
LineShader作って。モデル変換だけの、ライティング使わないやつ。いちいちライティング切るの面倒だから。
とにかくVNTFLでは多すぎるのでVNFがデフォルトになるように何とかしようね
LSですが
setUniform("uMonoColor", [1,1,1,1])ってめんどくさいです
fillにしよう
そんでカラープリセット使えるようにするよ。文字列指定。
長さ1,2,3,4に応じて場合分け、加えて文字列、加えて配列、長さで分ける、列挙、はい。
文字列の場合、たとえば"hsv 1 1 0.5"とか出来るようにする。つまり文字列の場合、hsvが使えるわけ。
もしくは"hsl 1 1 0.5"... hslは？作るよ。"rgb 1 1 1"/"rgb 1 1 1 0.5"とか。
長さ1: r,r,r,1 長さ2: r,r,r,g 長さ3: r,g,b,1 長さ4: r,g,b,a 配列もしくは"rgb/hsl/hsv 数 数 ..."の場合もこれに準拠。
それは内部関数で用意しましょ. 文字列でひとつめがrgb,hsl,hsvまたはプリセットの場合はそれが出る形。
strokeも作る？線描画用の線の色を決める関数。ユニフォームの。

monoColor()でいいと思う。どっちも同じ名前使いたいし。
LS.monoColor(0,0.5,1,1);

線に違う色を使いたい？ぜいたくね...Cの次はDだからDでいいと思う。
D... lc:{name:"aLineColor",size:4}
VNTCDFL...（長いよ）
コードについては初めにアルファベットの並びを一文字ずつ区切ってそれぞれがV,N,T,C,D,F,Lのどれかであるなら
そういうものとして作ります
それが無い場合は登録してあるプリセットが利用されます
登録はregistFormatで名前で登録すると使えます
registFormat(keyName, {記法});
attrsとindicesという二つのオブジェクトを用意してそれぞれキーでわけて
キー:{name:~~~~, size:~~~~} ですね
いわゆるカスタムフォーマット
たとえば？ {attrs:{i:{name:"aIndex",size:1},d:{name:"aData",size:4}}} とかそういうの。いくつか翻訳機を用意しておくとかするといいかもしれない。
まあ使わないだろうけどね。
使わなくてもできるしな。

tukareta

やることが多すぎて何にもできないから整理してよ。でないと何にもできないよ。

一番やりたいことは何？
やりたいこと...
p5のオビコンを殺したいです。
これが一番上にあるのがもう精神的に耐えられないです
殺して

できたよ
定数の調整クッソ面倒
あとやること
とりまダブルクリックでloadState("default")が呼び出される様にしましょ
で
p5wgexにfoxIAを移したうえで
従来のカメラを破棄して
これで...まあいろいろ書き換えないといけないのですよね。大変。従来のカメラは死ぬことになる...どっかに移してはおくけどね。
同時にp5のオビコンの書き写しも死ぬことになります。もう不要ですから。さようならp5のカメラ。ばいばい。
あとはslerp実装して終わり...ただそれはどっちかというと、まあいいか。
CCを呼び出さない場合に...んー。
ですね。
タイマーやめよう。毎フレームでいいや。戻そ。

2023-09-11
とりあえずカメラを新しくしました。
今やることは3つです
TODO
Vec3にstatic形式を導入。あとmagSq作ってください
normalize()で大きさが0の場合に0にする
LSにuse()を導入してusePainterと同じ意味に
回転体メッシュ（後回しでいい）（というかattribute周りはもっと洗練させたいんですよね、今後の課題。具体的にはvやfに追加属性が欲しい）
LSとCCの連携、camsの導入、tfの導入、renderPrepareの廃止。
この3つをとりあえず目標に。
時間があったらカメラ関連のマニュアルを作ってね。お疲れ様でした。ほんとうに。
時間ベースで動かすアイデアもあるんだけど毎フレームの経過時間でやるのがちょっとあれなのよ...pause使えば行けるんだっけ？

Timerの、バグではないんですが、経過時間と差分をごっちゃにして扱ってて、若干使いづらかったのを修正してました。
getDeltaなのに差分ではなく累計を返す。累計はelapsedでしょう。おかしいんですよね。なので直しました。
これで毎フレームsetDelta(name)を実行するのであればちゃんと差分が返るようになります
何らかの事情でプログラムを止める場合、pauseすれば差分はちゃんと0が返るし、いろいろきちんとなります。
pauseのあとreStartする場合にも、reStartの場合に差分取得に使う用のstumpをリセットするため、ジャンプを防ぐことができます。高性能です。
要は、差分取得用と累計取得用のstumpを分ければよかったんですよね。
p5もmillis()とdeltaTimeという形で分けてはいるんですが、deltaTimeがジャンプしてしまうのですよね
millis()もおそらくジャンプする、これはバグではないんですが、ジャンプしない場合の値が欲しい場合に不便なのですよね。うーん。
どうしよう？
どうもしなくていい。ポーズしなければいいだけ。プログラムに応じて決めればいいだけの話。何ならスロットを増やせばいい。ただそれだけの話。no problem!
もう仕様変更には関わらないんだし、p5のことは忘れてしまえばいい。
時間管理がやりやすくなる代わりに単純なことしかできないせいで柔軟性を失ってるのが今のp5なんですよね。まあp5は全部そうですが。
slerpの作例もひどいものになりましたね。2Dオンリーときたもんだ。はぁ？って感じ。
loop/noLoopって全部止めてしまうんですよね。一部の時間経過だけ停止させたい場合に凄く不便。そのためにTimerを導入したんですよね。個別に操作できるように。

TODO
予定外の処理をしてしまった
あのね
リセットが時間ベースなのにインタラクションがフレームベースだと不釣り合いですよね
そこら辺です要するに
選べるようにしようねって話ですね
タイマーと、それのポーズ/リスタート処理を設ければ、時間ベースでインタラクションを記述できるでしょう！

　・オビコンに時間ベース処理を導入（fps60相当の時間ベース処理を導入）、スマホでもfpsによらず動かせるように。
　　これは難しくなくて、一度やりかけてますね。定数を軒並み60倍して、更新の際に経過秒数を掛けるようにするだけ。
　　それできちんと動いたんですが、そのあとやっぱやめようってなったんですよね。それをオプションとして復活させます。
　・Vec3にstatic形式を導入。これも単純作業なので難しくないですね。
　・LSとCC,CMの連携。registとsetを共有。camsとtfを導入（tfは一つでいい）、renderPrepareの廃止（transform関数でいじる）
　　難しい処理があったら後回しにしてもいいけど、camsとtf導入するくらいなら一瞬で終わりそう。

これらが終わったらとりあえず一段落、ですね。あ、なるほど？
ああそうか
Deltaを呼び出すたびにperformance.nowで置き換える、あああ！どうして気付かなかったんだろ...
getDeltaMillis()を呼び出すたびに、差分を取っておいた後で、deltaStumpをwindow.performance.now()で置き換える！？
それでいいじゃん！あほかぁ...そうしよ。
setDelta()は廃止。getDelta(Millis)は最後に呼び出したときとの差分とする。なので正しく差分を計算するなら毎フレームちゃんと呼んでね。
そもそも経過時間を使って何かする場合、毎フレーム呼び出すのは大前提なので、特に問題ないと思う。
新しいこのTimerでFALさんのあれを書き直せたらいいのだけどね。

オビコン時間ベース導入したんですが
foxIAを改良して簡単なインタラクションを作れるようになりたいんですよね
例えばですけど
即席でキーアクション作るとかそういうの
できたらでいいのでよろしく
function keyTyped()でデバッグやったんですけどいちいちp5に頼るのもあれなので

今の仕様でキーたたいたらなんかってのを作る場合
まずclass MyKeyAction extends foxIA.Interaction{
  constructor(){}
}
ごちゃごちゃ～～～～～～～～～
ってやらないといけないので非常に手間がかかるわけ
デフォルトでなんか
class Inspector extends foxIA.Interaction{

}
もしくはfoxIA内部にこのインスタンスを作ってしまう
exportする。
const IR = foxIA.createInspector({keydown:true});

IRには様々なマウスダウンやキーダウンなどのアクションを動的に挿入できるし変更もできる
たとえばキーをたたいたらどうこう、ってしたいなら
IR.keyDown((function(e){
  if (e.code === "Space") CM.stop(); // スペースキーを押したら停止
}));
とかするなど。簡易版なので引数の関数で差し替える感じでいい、複雑なものは要らない。
今考えてるのは
mouseDown,Move,UpのDefaultActionとkeyDown,keyUpだけ。今はそれで充分
テスト用だしマウス前提で。そんな感じ。
IRでmouseXやmouseYを取得するテスト成功です。p5を離れても大丈夫なようにね。
さてと。

LSとCC,CMを連携する。CCもCMもカメラを動かすだけでは描画できないので。LSなどのRenderingSystemは必須。
LSとは限らない何かしらのカメラを使うRenderingSystemとの連携を可能にする。
CMと一緒で名前とカメラの組み合わせでいいと思う。とりあえずは。あとtfを内部に用意しましょ。
取得可能にもするけど基本的には外に出さない方向で...
getTransformで取り出せるようにするけど。

たとえばCCとCM,CCとLSだけ連携する。こうするとLSサイドだけとっかえひっかえでCCと連携するLSをチェンジすることで
CCでsetやregist...
まあいいや。
RSのupdateでCCと連携してる場合にCCのupdateをするようにすればCCもグローバルにしなくてよくなる
さらにメッシュの登録もできるようにすればmuも要らなくなるかも

CCとCMの連携は廃止します
LSとCC,LSとCMの連携をトップダウンで実行します。そういう形にする。
CCにCMを備え付けてCC専用のCMとすればいい。スムースリセットはオプションでオンオフすればいいのです。
逆連携も要らないので廃止。記述がめんどくさいくせにメリットがない。やる意味がない。
LSでCCを使いたい場合は登録という形にする。連携ではなく登録。
CMを使いたい場合も同様。updateはそれぞれをupdateする形で。つまりCC用のCMとCMとしてのCMを分ける。
役割が違うということ。これでいろいろうまくいく。

とりあえずできました
CC,CM,LS,RS大幅に変更しました
CCは相当改変したのでほぼ原型とどめてないですね
柔軟性を高めることを主眼に設計したのでだいぶ使いやすくなってるはずです

LSの仕様変更
カメラは登録されたものが使われる仕様です
トランスフォームは備え付けです（個別に用意することも可能）
setTransform(process)でtfをいじってsetMatrixUniforms()で行列ユニフォームをセットします。renderPrepareは廃止です。
そのあとドローコール。個人的にはドローコールを関数化してその中で行列ユニフォームを、でもいい気がしてる。なんならライトのあれもまとめて。
TODO
meshutilでvとかfにも追加でオプションを設けられるようにする
ラインシェーダ

noLoop()は要らないんだよな
window.alertが1回しか呼び出されないようにすればいい
内部でクラスを用意してそれにアクセスしてエラーを出して
そのクラスが同じエラーを複数回出さないよう管理すればいい

CCバグってた
defaultConstants={}初期化ミス
まあいいや仕方ないわ

factorのとこがfrでなくfになってた
Inspectorのイベント名を合わせました

lightOffやlightOnもあれ...うーん？そうね。どうしようか。

TODO
更新お疲れ様でした。他にも色々やりたいことがあるのです
・グラデーション背景を作りやすく
結局CPが使いづらいんですよね。グラデ背景だけ欲しい場合とかあるので。そういうの作りやすくしたいんですよね。
・アニメーション
カメラの、まあCMですけど、CMって今fromとtoとeasingとでやってるじゃないですか。これをですね。
stateの列...要するにcompositeMultiみたいなことがしたいわけ。あれの、valueのところをstateにして、prgにイージングを掛けて
2つのvalueの補間をしているんですが、これをstateの補間にする。だから、クラス用意すればいいと思う。両方に適用可能な、クラス。
想像したのはアスペクト比で画面の伸縮のやつやりたいなってなったときにそういうの欲しいねって話になった
それだけ
しょうもなかったら
やらね
疲れるし
・線シェーダ
線引くときにライティングをライトオフで実行するのはダサいのでやめたい
そういう話
p5のimage()みたいでダサいのでやめたい
・自前でエラー処理
これについてはアウトラインができてる、というか要は同じエラーを1回しか出してほしくないだけなので、文字列照合でいける。
そもそもエラーにならなければ呼び出されない。何の問題もない。スタッツ表示機能も付けるつもり。
・色指定
具体的にはuMonoColorの設定とかclear()ですね、あれの一時的な色指定とか、そういうのを出来るようにしたいのです。
いまちょっと出来ない感じなので。
・正方形のメッシュで対角線の線をlに入れないオプション(diagonalLine:false)を作る
・（完了）TimerにcompleteFunctionを導入しcheckの際に実行されるようにする
・正則行列の極分解、対称行列と単位行列の補間の導入、直交行列と単位行列の補間のメソッド化etc...

今考えてるのはそんなところだけど
どうでもいいなら全部破棄してBloomと流体の方行っちゃっていいよ
もしくはテッセレーション、それによるsliceAnimationのp5wgex化。あれもlibtessに依存してるからいい加減やめたいし。

以上
やめたいならここで終わりでもいいよ。やめた方が幸せになれるってもう何度も言ってきたし。
ね。
アニメーションの補足
animations={}
useAnimation=true/false
curAnim = "";
useAnimationがfalseもしくはtrueでもcurAnimが未定義の場合、fromとtoとprgとeasingから自動的に即席の
アニメーションオブジェクトが作られる。そうでない場合はアニメーションが作られるんだけど。
class Animation{
  constructor(params = {}){
    this.animations = {};
    this.mode = "clamp"; // clamp,loop,reverseLoop, inverseの4種類
    this.executor = ((from, to, progress, modifier) => progress); // 出力用関数
    this.regist("default", {
      v:[0,1], t:[0,1], m:[""]
    });
    //this.curAnim = this.animations.default; // デフォルト. 入力を0～1にclampしたうえでそのまま返す感じ。
    // ちなみにこの中には加工する関数だけが入ってる。これをmodeとexecutorで加工したものがactionになる。
    // それとは別に、直接値が欲しい場合はapplyで取得することもできる。
  }
  regist(name, data){
    // animationの登録関数
  }
  apply(name, t){
    t = this.wrap(t); // modeに応じた処理
    const result = this.animations[name](t);
    return this.executor(result);
    action要らんわ。applyだけでいい。
  }
  //action(t){
    // tに応じて
    t = this.wrap(t); // modeに応じた処理
    const result = this.animations[](t);
    return this.executor(result);
    // これでおわり。
    ~~~~
    タイムスタンプベースで計算していく
    0から始まり1で終わることが想定されており、valueもそれに応じて同じ個数だけ用意されることが想定されているが、
    バリデーションが面倒なのでそれを想定したうえでバグが出ないようにプログラムを書いてしまおう。
    タイムスタンプを下から見て行ってk番より小さいならvalueのk-1とk, 的な。で、value[k]がおかしくなりそうならもう最後の値だけにしてしまう。
    つまりvalues.length>timeStumps.lengthだと途中で終わってしまうし、逆に<だと途中から同じになってしまう。
    意図した挙動が欲しいなら同数にしないといけない。
    間隔に応じてmodifierが選択される
    これはprogressの加工もそうだけどfromとtoをいじるなど、何らかの処理をfrom,to,progressに施すもの
    基本的にはprogressにイージングを掛けるための情報の取得に用いられるがいろんな使い方を想定している。以上。
    return {from:~~, to:~~（この2つはvalueで実際の値だったりベクトルもOKだしカメラのstateなど色々）, progress:~~, modifier:~~（たとえばイージングの種類）}
    たとえばベクトルでイージングの種類をxとyごとにしたいならそういう使い方もできる

    取得した後それをどうするかは使い方次第
    Easingでこれを使いたいんだけどね。どうなるかしらね。
    return this.executor(result); // こういう形になる。
  //}
  wrap(t){
    // modeに応じた処理
  }
  setExecutor(func = ((x) => x)){
    // {from, to, modifier, progress}に対して作用する関数で、何かしらの値を返すものを設定する
    たとえばfrom * (1-prg) + to * prgなど。modifier関係なく。modifierが文字列でそれによりイージングを呼び出して云々
    とかそういう使い方もできるわけ。
    this.executor = func;
  }
}
ということはEasingをこれの継承で書き直す流れですか？そうかもね。ただどっちかというと何だろ。うーん？
Easingはデフォルトでイージング系の関数が用意されていてexecutorにもそれを考慮したうえで結果が出力されるような
物があらかじめ備わっている状態ってことにすればいいと思う。
_prg = this.ease[x.mod](x.prg);
return x.from*(1-_prg)+x.to*_prg
これがもともと備わってて、またeaseに関しても例のあれが一通り放り込まれているのです
よね。
たとえば継承先でも

setExecutor内部でthis.ease[x.mod]って感じでやれば使える、使わなくても出来る、
fromやtoがベクトルのanimationを作ってそれとイージングで何かしたりもできる、lerpではなくslerpも可能、
そこらへん高い自由度を実現するためにこの形式で行きましょうか。
継承やめよう。Easingにコンポジットする。で、executorだけとっかえひっかえできるようにする。
カメラのステート遷移も同じようにしてできるはず。コンポジットの場合executorをいじらせたくなければそのようにできる（表面上は）
ので、コードが綺麗になる。そもそもあれイージング組み合わせてるし。

stateで、アニメーションがオフの場合はdefaultをシンプルなもので上書きしてそれを使えばいい感じですね。
オンの場合はセットされているアニメーションが使われますね。
イージングクラスについては継承ではなく、コンポジットで。
関数を増やすときにこれを使えばいいと思う。
CameraManagerについてもこれをコンポジットしてexecutorでカメラ使ってstateであれしてってやる。
bindを使うとexecutor内部でCameraManager自身の情報が使えるため、カメラのlerpStateを呼び出したりなんてことも可能になるわけ。
その場合出力は存在しないが...まあ、なくてもいいので。（return 0とでもしておけ）
bindを使えば可能です、
この手のあれもたしかFALさんがやってたと思うよ。FALさんも独自のタイマー使ってたから。

Easingをより柔軟に使えるようにしたいのですよね
executorとして...
animations = {
  default:{
    loop:"clamp", action: (x) => {from:0, to:0, prg:x, mod:""}, executor: (x) => x
  },
  myAnim0:{

  }
}
つまりaction関数とexecutor関数の組として定義すると？
applyで...
そんでもってapply
executorもいろいろ用意すると？んで文字列だ。定義？...
animations = {
  default: {action:"default", executor:"default"},
  myAnim0: {action:"myAction0", executor:"myExecutor0"}, ...?
}
actions = {~~~}
executors = {~~~}
こういうこと？
registAction(name, data)
registExecutor(name, data)
valueの内容に応じたexecutorを用意したい場合、この方がいいこともあるでしょう、みたいなやつ。
もしくは予めいくつか用意しておくのもありかも？具体的にはVec3のlerpとかslerpなど。

4行。
const anim = this.animations[name];
x = anim.loops[anim.loop](x);
result = anim.actions[anim.action](x);
return anim.executors[anim.executor](result);

registLoop(), registAction(), registExecutor().
executor内部で自身のeaseを使ってmodの情報からイージングを呼び出してそれを用いるのがEasingクラス
executor内部で自身のcurCamを使ってカメラのlerpStateを実行し戻り値は特にありませんってするのがCameraManagerクラス
で
問題は...
自己参照？にはならないよ
easeの内容は単なる関数だから。それを直接呼ぶこともできるし。applyEase(name, t)
applyでanimationを使えばいいと思う。従来のapplyをapplyEaseと改名して、...
actionに関しては...
もしくは？actionsだけでしょ、違うのは、だったら...
改名しなくていい
nameがeaseで引っかかったらeaseの方で出力すればいい。従来通りapplyでいい。
それとは別にアニメーションの登録をすればいい
executorもloopもとっかえひっかえ出来た方がいい。登録には文字列のみを使えばいい。これでいこう。

取り急ぎ
1: WireframeShaderって名前で線シェーダ作ればいいと思う。色指定整えたら単色出来るようにするね。頂点色も出来ればいいけど。
2: loop,action,executorですか。loopよりwrapの方がいいと思う。たとえばregistWrap()でwrap処理を追加して登録する。
それで完成でいいと思う。Easingでテストしていい感じなら反映させよう
TransformのstateLerpですけど多分極分解と対称行列の固有分解による単位行列との補間でいけるんじゃないかと
以上

from, to, valueはどれも同じ内容でそこにmodifier
補間を実行するexecutorの種類は様々
fromとtoとprogressから単純に補間するのが基本だがたとえば変わり種として
ベジエハンドル(p,v)とかね。pにおけるベクトル。p-v/2とp+v/2がベジエの制御点。(p,v)～(q,w)で途中をベジエで補間する。
一般の場合は...(p,v)でp-v,p,p+vの方がいいか。(p,v1,v2)でv2が未定義の場合は-v1みたいな。
(p,v)～(q,w)でp+v=q-wの場合が2次ベジエ、そうでなければ3次のベジエ。これとprogressで補間するイメージ。
イージングもベクトルのslerpもあらゆる概念を内包する。出来ればね。
actionの中身のv,t,mはとっかえひっかえできるので何でもありです。たとえばvの中身をポインタで書いてその内容だけ外部でいじる
みたいなことも自由自在ですね。いろいろできますね。
さらにcompleteFunctionという究極の機能が...！
completeFunctionはCMに付けたら？というかあれか。Timerに付けたらいいんだな。
executorでTransformのlerpStateとかできるようになるといいね

しかし極分解って対称行列と直交行列の積にする...ということは一般の正則行列による変換から直交成分、ああ！それで極分解か。理解できたわ、なるほど...
固有値分解ができれば難しくないと思う。すべて正の実数なので三角関数のあれが使える。問題はそれで固有ベクトルを出した後ですね...
それで分解して固有値を1と対数補間すれば割と簡単にいける。おそらく2DのTranssformも同じようにできる。

TODO 追加
・4次元ボックスとかトーラスとかそういうののプロジェクションで回転とか反映させて3次元に落とすのが流行ってると聞いて便乗したい
出来ればでいいです優先順位低
・直交行列と単位行列の補間のメソッド化、これによる正則行列（3次、もしくは2次？）の単位行列との補間（というか極分解）
　...によるTransformの補間など
・トランジション。2つのカメラで2回レンダリングしてそれらを透明度で補間する、テクスチャの補間を作って応用すればいいのでShaderSystemの派生で出来ないかなと
思うんだけどどうだろうね
・CopyPainterがオプション多すぎてなんか使いづらいので廃止してShaderSystemで新しくなんかつくりたいね
テキストをキャンバスに載せるだけの簡単なツール作ってそれでいろいろやりたいねp5若干そこらへん不便なので
まあそこまで不便ではないんだけどちょっとね
・ブレンドモードって描画時に前後で指定するだけでしょ？やりたいことは2つ。
ひとつはブレンドの内容をモードごとに決めてキーワード指定にする、あのあれ、ADDとかDIFFERENCE的な。
もうひとつはそれでサンドイッチするのをしやすくする。たとえば
_node.blend("blend") ~~~~~~~ _node.blend("none")
"blend"や"add"で自動的にonになるのでめんどうなenableは不要。noneにすると切れる。逆に"use"にすると最後に指定したモードになる。
デフォルトではブレンドは機能しません。
たとえば"blend"しか使わないなら初めにblendしたあとでnoneして、あとはuseとnoneだけ使う、といった使い方ができるわね。でもまあそれなら
この仕様なら
"blend"/"none"でいいか。でもuseは要ると思う。で、その場合curBlendを把握しておく必要があるわね。
今ああいう状況なのは柔軟性を...ってのがあるけど実際BLEND以外使ってないのよね。だって要らないんだもん。
・フィルター
ブルームもだけどそのうちフィルター欲しいわね
フレームバッファはこっちで用意してそれを登録...
フレームバッファもしくはテクスチャを使ってそれを放り込む？初期化時にオプションに応じてフレームバッファを作らせればいいんだ。で、
実行させるとそこに結果を転写してくれる。あとはそれを取り出す仕組みを作ればいいし、そのままnullで描画してしまってもいいし。そんな感じ。
ブレンドは描画時に指定したいところ。うーん...
・ドローコールを一元化してLSにも導入できたらいいななんて思ってる
draw({
  type:"arrays", mode:"triangles", blend:"blend", instanced:false
});
params: type(default:"arrays"), mode(default:"triangles"), blend(default:"none"),instanced(default:false),
first(default:0),count(default:figureごとに事前計算された値),instancedCount(instancedの場合)
そうすれば描画時だけ特定のブレンドモード、みたいなことができる。想像。

って感じ

まあ、やらなくてもいいのよね。疲れるし。

EasyCamのやつ見たよ。がっかりだね。OrbitControl改善する必要、やっぱなかったね。はい。
いいよ、なんかもうそれどころじゃないしな。

クーシさんが快癒しますように。

正則行列と単位行列の補間のアウトライン：
Mに対してA=M * transpose(M)を作る
Aの固有値3つ（正の数）を取って固有ベクトルも取ってA=V*D*transpose(V)と表し、L=sqrt(D)を作る。
S=V*L*transpose(V)を作る。ここでLをIと対数補間する。
一方U=V*L^(-1)*transpose(V)*Mを作るとこれが直交行列になる。なのでIと補間できる。
実はM=SUである。だからSとUを補間した結果を掛け算すればMとIを補間できる。めでたし。
メソッドとしては
正の固有値3つをさらっと導出してそこから固有ベクトルの成分を出すやり方が欲しいですね

Blenderはtranslate,rotate,scaleの順番を厳密に定めることで
この手の問題が生じないようにしているんだね。
...
たとえ2Dでscale(2,1)とrotate(PI/4)の順番を変えると軸が歪む
こういうことが起きないようにしているんだろう

4次元boxの頂点や辺をvec4で作ってTransformFeedbackでvec3に落としてやれば描画しやすいかもね

とりあえず気になったもの
・TimerのcompleteFunction
・bloomと流体
・Animationクラス

4次元boxの作りかた
step1: 普通に4次元のboxのメッシュを作ります

面なんて作れるわけないだろ。あほか。
がむさんのあれも多分面は作ってない、というか不可能のはず。ワイヤーフレームしかできないだろ

おまけ
例のデモですが、あれは面の問題を回避しているので超簡単ですね。インスタンシングかなんかで頂点の位置をいじるだけでいいと思う。
んでつなぐ線をワイヤーフレーム（no diagonalの方が見栄えがいい）で表現すればいいんじゃないかと。
なんならTF～インスタの3D版の実験台にしてもいいですね。あれまだ2Dでしかやってないので。もしくは普通にインスタンシング...球は重いので。

completeFunctionが採用されました
いろいろ提案しましたが
まあ
多分2～3個くらいしか採用されないでしょうね

checkをupdateに改名して、毎フレーム呼び出す関数を用意して、
それがtrueを返す場合setElapsedで抜けるみたいな感じにすればいい。
もはやタイマー関係ないが...durationはInfinityを設定するのだろうか？まあelapsedはそれでやってるけど。
却下ですね
毎フレームならそれがtrueを返したときにsetElapsed()を呼び出す処理を外側で書けばいいだけの話でtimerに作る必要ないし、
今更checkをupdateに改名するのも手間だし、そもそも時間ベース挙動を作るために作ったのにフレーム制御に寄せるのも不自然だろ。
却下。

completeFunctionで引数が無い場合に自明関数()=>{}をセットする仕様を追加します
これにより用が済んだらcompleteしても何も実行しないようにできるようになります
そういう仕様もあった方が便利かもしれないと思うからです
stepFunctionを導入します
毎フレームではなく
getProgressの中で実行します
こうすることでいちいちconst prg = ~~~~~ とか書かずに済む
ただ万能ではないし、引数もprgとthisくらいしか使えないのであくまでも簡易版です。
時間ベースでprgに従って毎フレーム何らかの処理をさせたい場合に使えるというだけです。
completeFunctionにしてもいちいちif(check())~~~~~ とか書くのが面倒だから用意しただけだし。それにしたって外部の変数、
スコープ的には使える変数が使えなかったり、一長一短なので、まあ使い方次第ですね。

Animationと連続処理。activateの重複をなくして、modで音符を用意してtでインターバルってやって適当に発火させて一定時間したら
check(name, Infinity)で切ってしまう、みたいな？setElapsed(name, 100とか200) ~~~~~ check(name, Infinity) の流れ。
この場合valueは仕事しないが、
まあいいや

アイデア
キャノンボールプロブレムの可視化：1^2 + 2^2 + 3^2 + ... + 24^2 = 70^2.
StandardNonLightingSystem. ライティングしないバージョンの立体描画機構
FALさんのリズムジェネレータ

・ランダム周りのいろいろ
1次元ランダム、ノイズ、球面上や半球上、球内や円内のランダム抽出
そこら辺の関数欲しいですね
それもおいおい整備していくつもりだけど時間が足りないです
難しく考えなくていい
「これがないと不便～」を積み重ねていくだけ


緊急
ShaderPrototypeだけど
initialize()が仕事してない
パラメータを全部破棄しないとinitializeとはいわない
uniformが残ってしまうのとか全部クリアしないと駄目
だめです...多分
今のinitializeをsettingで改名して
initializeで全部破棄すればいい
そんだけ
setting内で破棄させるのでsettingのたびに設定がクリアされて必要な情報だけ付加される
最終的にデフォルトのinitialize()で全部用意して、継承ではそれをsuperで呼び出すことで解決しました。

加えてコピーペインターがいろいろバギーなので破棄して
つまりPerformanceCheckerも破棄して
DOMかなんかで書き直すつもり
frameRateもTimerを持たせてそれで自前で計測させる
色々変えないといけないです

今現在
通常のblendingとone, one_minus_src_alpha以外何にもやってないので
デフォルトを"none"として
その他に"blend"としてこれを用意する
それ以外はとりあえず
いらない
だからその2つだけ用意すればいい
ですね。

copyPainterを廃止してPlaneShaderのoptionで実現するか、もしくは、
PlaneShaderとは別のtextureを描画することに特化したShaderPrototypeを新たに用意する
だって常にuTexとかuTex0,uTex1,...があるわけです、板ポリ芸ではないわけですからね
TextureShader(仮) とかね。
BackgroundShaderとかCoverShaderとか色々変種を考えるのも楽しそうですね
CopyPainterがいろいろ全部担っていたのを役割ごとに分けましょうってことです。あれが全部やってたので。
もうお役御免でいいでしょう。お疲れ様でした。

イメージ：drawArrays("triangle_strip", {blend:"blend"});
ある程度の自動化は必要かもね。内容が単純な場合限定だけど。ターゲットのfboと、あとはオプション、ブレンド、ドローコールも固定だし。
単にテクスチャを描画するだけなら自動化されていないと確かに不便ではあるのよ。うーん...
まあ実際、新生PerformanceCheckerがそういうことしてるんだけど。
fboは別に指定しなくていいだろ。それは外でやることだ。中ではblendだけ意識すればいい。
だからドローコールを↑のようにしたうえで、CopyPainterに相当する別の機能を作ればいいんだわさ
新生pfcでやってることをTextureShaderとか、BackgroundShaderとかで同じようにやるだけ

・Geometryの変形関数を充実させる。とりあえず3つ。
・ベクトルのstatic（リマインド）（はやくやれ...）
・色指定の充実（リマインド、今現在clearColorとか色々指定するのに不便、透明度1の指定し忘れが頻発してて不便）
（・リサイズの探求、暇ができたらでいいです。特に理由はないけどp5のオビコンがリサイズ対応してないって馬鹿にされてるので）
（・snipetの充実。hsv2rgb使ったけど便利でした。やっぱああいうのはテンプレ化しないと。）
Geometryの変形関数。具体的にはshrink, twist, uvModify.
shrinkは原点とベクトルを指定して、原点中心の球を考え、その球の上にあるメッシュの頂点を、極座標で表示する。
んでそのファイ（0～2pi）は基本的に変えず、テータ（-pi～pi）を動かす感じ。f(ふぁい、てーた)＝新しいてーた、です。
変形した後でcalcNormal.
twistも原点とベクトルを指定して、ベクトル方向の距離に応じて、それは変えずに、回転角をいじる。ベクトルから見て反時計回りに。
そのあとcalcNormalする。
最後にuvModify,これはuvの関数を用意したうえで、それに応じて頂点を法線方向に動かす。正の時法線方向にずらす。
ウェーブを掛けたりできる、はず。そのあとcalcNormalする。
次にGeometryの関数で、vcを用意する関数を2つ。vcってpositionから決めることが多いでしょ
setVertexColorsWithPosition(), setVertexColorsWithUV()を用意。引数は結果が色指定の引数になる関数。
具体的には長さが3とか4の配列。文字列でもいいし。そこから色を作る関数にぶち込んで最終的に長さ4の配列にして
vec4のvcに順繰りにぶち込んでvcとする感じですね。いや、破棄する。破棄して完全に置き換える。追加しない。
vcくらい手軽に用意できたら便利でしょ？
以上。

追加
・GeometryのgetVerticesが欲しいです。デフォルトでマージ済みの頂点集合を返す。たとえばトーラスとか、正二十面体とか。
あったら便利そう。
あと面の上の点をランダムに取得して返すとか。そういうのあったら面白そう。

曲げるのは闇が深そう
別のことして。いくらでも課題あるんだから。
blendはこうする
{blend:~~~~ 文字列か配列}
文字列の場合はプリセット。デフォルトは""で、処理をしないならこれ。
  今後enableなどの処理は非推奨とする...ドローコール時の処理は一時的にapplyBlendで行なう。
  getParameterを使って事前の状態に戻す。それ以外の方法でblendを設定するなら従来通りだから破壊的変更ではない。
  ただテンポラリーに描画時だけblendが欲しい場合の選択肢として、ひとつ。
  getCurrentBlend()
  そのときのブレンドの状態を長さ4の配列で返す。それはgl定数の4つ組。
  applyBlend()
  引数は文字列か、文字列の配列か、gl定数の配列。gl定数とはいえnumberなのでただの数字だが。配列の場合は
  ひとつ：[a,a,a,a], ふたつ：[a,b,a,b], みっつ：[a,b,c,c], よっつ：[a,b,c,d]とする。後者がalpha....念のため。
いたずらに変数増やしたくないのでpush～popはしません。状態取得でいいと思う。
というわけで
blendFuncとblendFuncSeparateは廃止します。getCurrentBlendとapplyBlendにしましょ。
またcopyPainterも廃止します。今までありがとうございました。
また相当コード書き換えないとですね。まあそのうち色々便利にするけどね。しばらくは不便だと思うけど我慢してね。
あれもうなんか、...意味不明。もう使いたくない。

メッシュ関数でマニュアル欲しいですね。使うパラメータとデフォルトの一覧。こないだtorusKnotでハマったので。
PerformanceChecker新しくした。frameRateを取得する以外は普通。0割り対策しといた。おけ！

おお...なんかなりゆきでsetTexture2Dを廃止、それはいいんだけど、copyPainterも堂々と廃止、それもいいんだけど、
drawCallですか。満を持して...って感じですね...これでまとめて実行できるんですね...
VAO?
何だっけそれ（うろ）
どうでもいいよそんなの
くっそどうでもいい
ああ導入するんじゃなかったあれ今すぐにでも廃止したいわ...まあ一応影響のないように導入したからいいけど...
バグの温床になるようなら切り離すからね。

とりあえずPlaneShaderでtextureを...
いいです
それはTextureShaderでやるので
そっちで、たとえばframebufferならフリップするとか、いろいろするから、いいです。
今回の仕様変更はドローコール全体に影響があります
なぜならすべてのドローコールをoptions方式にしているので
インスタンシングにも影響が出ます
地道に直していきましょ
あとcopyPainterが全滅するので覚悟してください

blendの指定、pauseの重複、色々あるね...誤字とか。まあ想定内だけど。
diagonalLineを部分的に導入
TF対応
Locaterを導入
TFはテストしないと分かんないですね
そのうち何とかするよ...

描画時だけblendするのお疲れ様なんだけど、デプスとカリングでもやりたいです。
あとblendのdisableで、もともとfalseなら何もしない方が速いと思う。falseなのにdisableするの無駄。
そんくらいでいい。
depthはdepthStateを用意してdepthMaskの状態とdepthTestの状態を記録する感じ
depthMaskの関数を用意してその際にstateを変更する
depthTestの場合も同様
たとえばdepthMask:true/false, depthTest:true/falseって書くと然るべく挙動する
PlaneShaderのdepthを操作できるオプションをやめて、renderないしはdrawを用意して、そっちで...
PlaneShaderは必要ないでしょう。それをやりたい。書き込みとテスト、両方やらない。
カリングについて
culling:true/false, cullFace:front/back/front_backから選ぶ。
stateについてもuseとcullFaceの状態を記録して復元可能にする。
これで一時的に別の状態にできる、はず。

LSのドローコール関数を用意したいですね。uniformのsetを一緒に実行してくれるとうれしい。いちいち書くの面倒。
とはいえ
複数回ドローコールが前提なので、回数が少ないならコードも冗長にはならんのよね。難しいところ...

とりあえずTextureRenderer作る。pfcみたいにオートでレンダリング出来る感じのやつ。
いちいち書き換えるのめんどくさくなってきた。
let TRとでもすればいい。
引数はtextureNameもしくは"fbo/" + textureNameで。フィルターとか場合によっては適用する。
あとPlaneShaderもそのままレンダリングできるようにしたいところ。あれもセッティングめんどくさい。
問題はユニフォームだけどあれも、たとえば{uColor:[1,0.5,1,1]}とか。...
ex.color("khaki")でそういう配列を出力してくれるとうれしいね。そういうの作れないの？
{uTex:"tex/" + textureName} {uTex:"fbo/" + fboName} でsetTextureやsetFBOtexture2Dが適用されるようにするとか。そういうの。
最初に/でsplitして最初のそれがtexもしくはfboだったらそういう処理をするみたいな。
もしくは...
RenderingSystemにまとめちゃうか？板ポリぶち込んで切り替えてレンダリング出来る感じのやつ。

PlaneShaderにレンダリングを追加
PS.render(shaderName, options = {uniforms:{}, あとは通常のあれこれ。blendとかdepthMaskとか色々});
あとpfcですがカリングも切っちゃおう。
カラーピッカー
色周りの整備（文字列で始めてr,g,b,aを指定）
文字列："rgb","rgb255","hsv","hsl","hsl_soft","hsl_overlay"から選ぶ。"hsl"は"hsl_soft"と同じ（柔軟性）
デフォルトは"rgb"なので基本的に0～1で4つの数字を決める。"rgb255"ならrgbaすべて0～255で指定できる。
[r]:(r,r,r,1) [r,g]:(r,r,r,g) [r,g,b]:(r,g,b,1) の省略が利用できる。
関数名はシンプルにex.color()とし、結果を長さ4の配列で返す。
文字列には他にプリセットが指定できる。その場合、そのあとの数字はalphaValueの指定となる（"khaki",0.5なら"khaki"の透明度0.5)
その場合はalphaは0～1限定とする。
hsv,hslの場合、まず数字の列をr,g,b,a形式にしたうえで、r,g,bのパートの部分に関数を適用して正しいr,g,bを導き出す。
たとえば"hsv",0.55,0.8,1の場合まず[0.55,0.8,1,1]としてから[0.55,0.8,1]部分をrgbに直してそこにalpha=1を付け加える。
"hsv",0.8であれば[0.8,0.8,0.8]をrgbに変換してからalpha=1とする感じ。おそらく使わないが...
文字列指定がinValidの場合は"rgb"が適用される。特にエラーは出ないので出力を見て判断してください。
あと"#9923FF"とか16進数コードでも定義できるといい。関数名はcoulour()で。color()だとかぶるので。coulour()にします。
ex.coulour("hsv",0.55,1,1)とかそんな感じ。ex.coulour("khaki")とか？文字列のプリセット用意する。以上。

setUniformを改造する。"uTex"などのユニフォーム名に"tex/uTex"とか"fbo/uTex"とか"fbo/uTex/color/0"とか(MRT用)
指定することで第二引数以降の挙動を決める感じにする。
keyに"/"を含めるのは可能みたいです。ただ、直接アクセスできなくなるだけ。たとえばa={b/c:4}と書くとエラーになるが
a={'b/c':4}は可能。さらにこの状態でa.b/cと書くとエラーになるが、a['b/c']ならアクセスできる。
そもそもa={b:3,c:4}は正式な書き方ではないのよ。a={'b':3,'c':4}の省略記法なのよね。ほんとは文字列ならほぼ何でも可能（なはず）で、
この書き方なら|や/も普通に使うことができるのよね。これを使う...ちなみに{'aaa':4, aaa:5}みたいに書くと後の方が採用されて4は破棄される。
{'color/uMonoColor':["hsv", 0.55, 1, 1]}とか？
setUniform('color/uColor', ["hsv", 0.55, 1, 1])的な。つまり引数の内容だけを書く。
setUniform('color/uTint', "#44ff55"); 引数が一つの場合は[]を省略できる。もちろん"khaki"や"gold"みたいにも書ける。0で黒、1で白だ。
setUniformsを使う場合、{'color/uTint':["#ff4455"]}もしくは{'color/uTint':"#ff4455"}みたいになるわね。
イメージ
setUniforms({
  'color/uTint':"#456aab",
  'tex/uTex':'bg',
  'fbo/uTex2':'colorLayer',
  uFlag:true
});
こんな感じ？まあ複数登録できると便利な場面なんて相当限られるでしょうね。メインはオート描画なのでどうでもいいですが。uniformsなんてただのおまけ。
引数0の場合はデフォルトで1,1,1,1とします。
setUniformの改変やめよう。いたずらに難しくしても仕方ない。

foxBoardは_nodeが作るんだから_nodeがやればいい。PlaneShaderの関数として定義するのはやめましょう。
色に関するクラス化、今は不要なのでいいです。
blendColorは色周り用意してからですね。それさえできれば...
alphaの事前乗算を仮定したうえで、const_color, one_minus_const_colorってやるんだと思う。
両方ともalphaが1の場合を考える。ベースにある画像を半透明でかぶせたい場合、その画像のalphaが1であるとそれがうまくできないわけだ。
そこでその画像のalphaをいじる代わりに、blendColorに0.3,0.3,0.3,0を設定して、const, one-constってやれば、透明度は
相手依存だから1で、それ以外のrgbが綺麗に補間されてかぶされる...はず。blendStateにcolorの項目を用意して、rgbaを保持する。
renderingの際に一時的に適用できるようにすると柔軟性が増す。

pfcをDOMのcanvasで書く仕様変更（レンダリングしない...重くなる）
検証が滞ってる。TFも確かめられてないし、setUniformsももっと検証しないとだし。いろいろ。加えて新しいInspectorの関数とか。
まあlogを振り返れば分かることだけどね...

renderTexture, renderMixTextureを作る
renderTexture(type, target, options={});
type: 'tex', 'fbo', 'color', 'gradation', 'texGrad'
target: 'tex'/'fbo'の場合は管理名を使う。'color'の場合はcoulour表記で色を指定する。
'gradation'の場合はグラデーションオブジェクトで指定する。{from:{color, x, y}, to:{color, x, y}, type:'linear'/'radial'}
複雑なことはしなくていい。シンプルに。複雑なことはPlaneShaderでカスタマイズでやればいい。
optionsにおいてblend:"blend", depthMask,depthTestはfalseデフォルト、cullFaceもdisableをデフォルトにする。

renderMixTexture({src:{type:~~, target:~~}, dst:{type:~~, target:~~}, mix:"~~", color:~~});
mixはalphablend, colorblend, screen,multiply,overlay,soft_lightなどなど. 2Dのlightestも作れるよ。alphablendしてから比較するやつ。
colorblendの場合はcolorでblend色を指定して、colorと1-colorでsrcとdstをブレンドする。coulour表記とする。

renderFilteredTexture(type, target, options = {});
optionsでfilter:~~~を指定する。グレースケールとかモザイクとかいろいろ。
filter:{type:~~, param:~~}. 物によってはパラメータが存在しないのでまあいろいろとね...
ブラーはあれ、doubleFBOでくるくるさせれば、出来ると思うよ。だから横とか縦とかそれだけ用意すればいい。

らちが明かないのでとりあえずrenderTextureだけ作ろう

仕様変更案
discardのオプション。trueにするとuvが外の場合に...ああそうね。
wrap: "": default.これは何もしない。で？
"clamp/repeat/mirror clamp/repeat/mirror"ですね。要するにね。長さ1の場合はどっちも同じとみなす。
"discard"だとuvが0～1の外ならdiscardを発する。1つ目が上の3つの場合、" "でsplitして長さ1なら繰り返しとみなす。
transform
uvとdisplayの2種類。それぞれsx,sy,r,x,yで指定する。PlaneShaderを仕様変更してpositionをいじれるようにする。2次元の範囲で。
displayサイドはたとえばposition+=0.5とかして描画位置を右に画面の1/4だけずらすなど。rotateして回転、スケールなど。
uvサイドは逆にuvが0～1x0～1の範囲がどこに落ちるかってのを、あれする。たとえば画面中央にサイズ半分で持ってくる場合、
sx:0.5, sy:0.5, x:0.5, y:0.5でいけるようにする。これはサイズ半分で、中心というか全体が...回転の中心が左上で固定なので難しいのよ。
じゃあどっちも同じようにいじれるようにする？？左上ベースじゃ回転を扱いづらいでしょう。
しかしこれを同じシェーダに組み込むのは荷が重すぎるので
renderWrappedTextureという形で別のshaderで実現します。仕方ないね。ごちゃごちゃするの嫌い。

今後の予定
↓こっちのあれこれの方がよほど重要。こっち最優先でよろしく。
renderMixTexture（複数のテクスチャでsrc,dstとし両者を組み合わせる。tex/fbo/color/gradに対応。
renderQuadTexture（最大4枚のテクスチャを用意してそれぞれ描画する。位置とサイズは一応指定できるが左上座標とスケールのみ。tex/fboのみ対応
renderFilteredTexture（tex/fbo/gradが対応する。フィルターを掛けてそのときのfboに落とすだけ。blurやりたいならdoubleを用意してね。）
フィルターは渦巻とかやってみたいね。
bloomとblurは別に作る。どっちもバックアップfboが必要になるので。

当面実装したい内容
雑談：TFやインスタンシング使えばピッキングをreadPixels無しで扱えるんじゃない？
GeometryのClassに頂点をマージして取得するとか面内の点をランダムに集めて取得するとかそういうの欲しいな～
そのくらいです。ブルームと流体が遠ざかっていく....
blendEquationの導入。blendEquationをいじれるようにする。レンダリングの際に一時的にいじれるようにするのもありだと思う。
floatのframebufferと組み合わせてフラグの管理とかできたら面白いと思う
applyBlendではいじらないようにしましょ。一時的に...ってのは難しいのよ。
名付けて、トランスフォームフィードバックピッキング。え？
TFだけでプロパティの変更を完結させるのよ。1x3のポイントスプライトを用意して...プロパティとしてactive,dx,dyを持たせる感じ。？
フレームバッファだ。えーと、floatで、1か0, dx, dyだ。で、ピックカラーからピックしてactiveかどうか見る...同時にユニフォームでactiveかどうか渡す。
p.xが正かどうかでactiveかどうか分かる仕組み。activeならdx,dyだけTFで動かせばいい。動かす量はdx,dyを換算するかそのまま適用する。

keyIsDown的なのを作りたいって要望が上がってる
keyDownとkeyUpだけだと押してる間だけどうこうっていうのが表現できないから不便なのよ
それと、マウス操作でキャンバスの拡大縮小とかやってみたい。ベースの、あるいはcreateしたcanvasの。リサイズの練習の一環
リサイズ時におけるコピーを流体の方でやってるけどあれ普通にrenderTextureでいけるはず。難しくない。カメラはいじってないし。
あとは...TFの簡単なテストですね。LSに導入したので。それとか。その辺です、よろしく...
あとTimelineに決まりました。あの、メトロノームのやつ。Animationとは別方向で作っていきたい。
あとあれ。ブレンドのMaxを使って複数のオブジェクトの同時activateできたら面白いねって昨日話してた。いつかね。

blendですが、何も指定しない場合デフォルトが使われるんですよね。
ただ板ポリで実行しているため、デプスとカリングの影響を受けてしまう。
それはウザいので
明示的にオフにしたいんですが
実行回数が多いので、いちいち指定したくないんです。そこで、push/pop RenderingStateです。
state系のプロパティを保存してあとで取り出す処理。
すべて保存してすべて戻す、でいいと思う。
ブルームの処理にデプスやカリングは不要ですからね。流体もだけど、あの手の処理にデプスやカリングの影響があるとまずいです。
ブレンドもノンブレンドを明示しないと"blend"が使われてしまうのでまずいです。

難しいね
coulourは配列も列挙もOKなんだけど
applyBlendは配列で["one", "one"]とかする代わりに"one","one"ができないのでそこら辺をちょっと修正
逆にblendEquationは["func_min","func_add"]のような適用ができないのでそこらへんで柔軟性を持たせました
renderTextureのblendのデフォルトが"blend"なのはまずいだろうということで""に直しました。
つまり直前の仕様がそのまま使われます。
depthとcullingについては切るものとします。デフォルトでは。
たとえばclearのあと文字、用意してかぶせる、などの場合、"blend"にしないといけないです。

簡易メッシュ関数。あった方がいいなら用意する。
調べたけどLIGHTESTとDARKESTは2Dの方やっぱスクリーン加算ですね。そりゃそうだ。じゃあこっちも倣おうか。おそらくですけど、
内容が同じでは無いので、それを雑に補正するのが目的かもしれない。まあいいや。全く同じものなんて出来ないんだよ。

setUniformsをなくす案が出たんですがとりあえず却下して逆にsetColorを作ることにしました。coulour表記を使いたい場合のsetUniform.
double-Framebufferはなくすつもり。あれあると色々障害になるので。
これを気にしなくてよくなれば、infoを保持するframebuffer classを作成できる
そのデータをそのまま使ってwとhだけ書き換えることでリサイズの足がかりを作れるようになる

グラデーションがclampしかないんですが、repeatやmirrorも欲しいですよね。そういうのはですね...
そのうちグラデーションに特化したあれを作るので待っててください。それでやるといいと思います。
たとえば黒、白、白、黒(0,0.5,0.95,1)のグラデーションのリピートとかでチェック作ったり？とか。
もしくはuvをいじって...テクスチャの...

// shaderに書いた通りです。
// まず、texやfboから採取する場合、それをそのまま出すならcol.rgb *= col.aは「不要」です。
// 不要ですが、
// その色をいじる場合、たとえばフィルター処理が代表的ですが、
// いじる前にrgbをalphaで割る必要があります。
// さらにいじり終わったら出力前にrgbにalphaを掛ける必要があります。
// That's all.

そういうことです。フィルターのシェーダを書くなら注意してください。
まあ終わった話題ではあるんだけど、これフィルターだけの話だと勘違いしてた節があって。
今現在、renderTexture()が既にバギーなので、直さないといけないです。
冷静に考えてみれば明らかなのよね
透明0.5の赤をいじりたい場合赤って1,0,0じゃないですか（[0.5, 0, 0, 0.5]のようになっている）
でも0.5,0,0になってるんですよ
だから1,0,0に「直す」必要があって明るさとか計算するにもこの「1,0,0」に基づいて計算しないとおかしなことになるんですよ。（適用前は[1, 0, 0, 0.5]）
しかし0.5,0,0に基づいてしまう...そして暗い値になってしまうのです。

ライティングシェーダにテクスチャサンプリングのデフォルトの記述はありません。
ですから、その都度正しい見た目になるよう、考えて実行してください。
って思ったんですがrgbにalphaを掛けるのが最後に共通の処理として控えていますね....なんてこった。まるでラスボスのようだわ♪
ふざけてる場合じゃないよ
この場合、texture以外の時のみrgbにalphaを掛けるか、またはrgbにalphaを掛けるのは共通の処理であるとしてtextureの場合だけrgbを事前に
alphaで割るかのどっちかですね。割ってからライティングを適用しないと正しい結果にならないですから。

ループ雲とかプリセットテクスチャに加えたいけど時間が...とりあえずsnipetに加えようかなぁ
ブレンドややこしいです
難しいですね
今言えることは
2Dのブレンドは...
まあ、難しいです。
というわけで、createMaterialColorを書き換えて乗算済みの値を返すようにします。加えて
mix一通り、filter一通り、まとめてスニペットにするね。

createMaterialColorは乗算前の値を返すことになりました。
2Dのblendの式が分かったので、それを使って乗算後の値を算出します。
で、colorは廃止、constantに改名、定数で単純補間することにしました。
uTintですか...えーと。どうしようね？
createMaterialColorの中にtintを含めることで、
それぞれ...
まあいいか。
blendが多岐にわたるのでその都度新しくshaderを作る...そのうち何とかする。

lightingShaderにおいてuseTexCoordを有効にする場合、最後のrgbにalphaを掛ける操作は不要になります（そのうち更新）
理由はalphaで割ってまた掛けてっていうのが無駄だからです
合理的な理由です
なので
createMaterialColorについては
テクスチャの場合は除算なしでそのまま返します
要するに何も特別な処理はしない...
Mixの場合は除算するけどね。blendの計算が乗算前前提だから仕方ない。
でも表示するだけなら不要でしょう。そういうことです。
二転三転して申し訳ないです。
あとあれ、textureGradationも用意しました。textureのr値で補間します。

saveですが
pushFBO()～popFBO()の出番ですね。fboをbindしたうえでw*h*4サイズのFloat32Arrayを生成しそこにTextureを
readPixelsで落とすようです。さらにclampを使って0～255に落とすようです。
というか
第一段階として、落としたいサイズのRGBAのフレームバッファを用意するんですよね。そこにfboにしろtexにしろ落とすわけ。
renderTexture()使えばいい。
で、そこからスタートするんですよね。そういう感じです。
registFBO("save", {w:落としたいサイズのwidth, h:落としたいサイズのheight})ですかね。
ここからスタートです。そういう感じだそうです。

saveの問題点を解消しました。canvasのセーブの場合、そのままreadPixelsで落とすのはやばいようです。
canvasからそのままセーブルーチンにいけばOKです。劣化が起きません。上下逆にもなりません。fbからのreadPixelsの場合、
サイズが大きくても劣化しないようです。原因は不明。

TransformFeedbackはDrawArraysの3種類限定です。TorusKnotで実験したらdrawArraysに切り替えたらとんでいきました。
とんでいきましたが、それがしたいわけではない。
というわけで
位置だけTFで変更するやり方、それならばOKです。

ぜんぶどうでもいい


ぜんぶどうでもいい


ぜんぶどうでもいい。。。
FALさんのコードを解析してた頃に戻りましょ
全部破棄
破棄！！！

もうやめようよ

射影テクスチャマッピングというのは要するにNDCでtexturingするだけ
プロジェクションほにゃららがこの原理を使ってるようです
ラスタライズってポリゴンを描画するんですがdepthを取得するのであれば不要ですよね
で
これはカメラ（ていうかMVP）さえあれば出来てしまうので
対象のポリゴンに対してマテリアルカラーとして用意できるわけです
チャクリさん
で、つまりまあたとえばビルみたいなのが立ち並んでいる状況でそこにこっちの画像を落とすわけですけど
普通に落とした場合
画面全体ですから、面白いことにならないわけ
そこで別のカメラを用意してそっちの画像が映し出されるようにする
それがおそらく正しい使い方なのでしょう
それとは別になにかテクスチャがあってそれとブレンドするとかだとなお、ですね。
だって実際のプロマにしてもビルの壁の質感とか、あるでしょう？

というわけでカメラが2つ必要になるわけね
片方はmvpしか必要としないけれどね
videoElementの導入考えようか...

videoの場合はvideoWidthとvideoHeightを取得すればよいそうです
https://lab.syncer.jp/Web/JavaScript/Snippet/36/
ありがとうございます！
HTMLVideoElementの場合にvideoWidth/Heightを使うようにしよう

h_doxasさんのサイト：https://wgld.org/d/webgl/w078.html

おわりました
鏡面反射と動的キューブ？
キューブマップでフレームバッファ
関連付けの関数framebufferTexture2Dを動的キューブマップのサンプルでは使ってないんですが
どうもあれ描画前にやればいいみたいであのサンプルでは描画時にコロコロきりかえてるのであそこではやんなくていいだろ
そういうことらしいです
こっちでもbindFBOを改造すればいけるぜ
って思ったけどやめよう
bindした後はテクスチャだけ切り替えればいい仕様みたいなのでそういう関数を用意した方が柔軟性が高いと思う
おそらく...
infoのtextureTargetにcube_mapを指定する
ただしtextureの場合です...attachType:"texture"の場合に、target:"texture_2d"かtexture_cube_mapを指定する
全部nullです
ちょっとまってもしかしてsrcになんかテクスチャのソースを指定するとデフォルトでなんかぶち込まれた状態の
？？
まあいいや
src.xpとかsrc.xnとかあるけどsrcがundefinedだとおそらくここでエラー食らうのでcube_mapの場合はsrc={}とでもしておかないとやばいね
ちゃんとnullが返らないと思う
src格納済みのfboはおそらく作れる...のか？分からん。実験してない。infoにsrc:~~~ってやればいいのかも？

まとめ
infoにtargetもう準備されてました（cube_map導入時にいじってあった）のでそのままtarget:"cube_map"とすればOKです
OKなんですがtarget:"cube_map"の場合にはそのあとcolorInfo.target = "texture_cube_map"になるんですがその場合に
connectWith～～をしなければいい、あとsrc={}が必要。これは!info.MRTのところで_createEachBufferの前に実行すればいいです。
いや、_validateForTextureでcube_mapでsrcがundefinedの場合に{}で初期化すればいい。
最後にbind時ですがRenderNodeの関数でframebufferTexture2Dを作って、.....
ああー
MRTのケース？おそらくだけどMRTで普通にレンダリングする場合の格納先を0でなく1や2にできる...ということみたいです？
もしくは読み取り時の0番オンリーを崩すのかしら。うーむ。attachmentとtargetについてdictを一通り用意してそれを使えばいいわね。
attachmentで1番以降も使えるの気になるけどまた今度でいいです
んでそれを使う。それ使って切り替えて描画するだけ。変更点は多くないですね。後はカメラの用意。
それだけですね。楽ちん

まあ難しいわね。やってみよ
今ターゲットにしてるのはこの動的キューブマップ、あとステンシル鏡面反射、パーティクルフォグ、各種フィルタ
ああまあsobelとlaplaはもうやったけど...ハーフトーンとラインが割と複雑なことしてたから気になってる

全然関係ないけどvertexAttribPointerのnormalizeFlagについて、これ、attributeのtypeっていつもfloatでしょう。
あそこをunsigned_byteにしてnormalizeをtrueにするとunsigned_byteがfloatに変換されるようです。この場合、
バッファには4バイトで色が格納されるのでバッファが節約できるようです。そりゃそうだ、0～255までしか表現できないものね。
なるほど...詳しくは：https://webglfundamentals.org/webgl/lessons/ja/webgl-how-it-works.html
ファンダメンタルは時間があるときにきちんと読まないとね...知らないことまだまだいっぱいあるんだから。

framebufferTexture2Dの仕様。そのときバインドされているfboに対して、そのテクスチャ（.t）に対する処理。

つまり.tじゃないのよ。デプスだってテクスチャになるんだから。そういうわけで...
framebufferTexture2Dですが、デプスやステンシルもあるわけ。そういうわけで、同じようによういしましょ。colorは未指定ならそれになる方向で。
どうせその形式で使うんだから。で、.tのところにはその、colorなりdepthなりが入る。まあdepthは使わないだろうが....
depthもtextureで使う場合はこれを呼び出してるんだよな。というか使ってる。でしょう？

よし。

ああそうか
MRTの場合にあれ使ってるじゃん。よく見たら。だからあれMRT用なんだよ。
/*
d.color_attach_0 = gl.COLOR_ATTACHMENT0;
d.color_attach_1 = gl.COLOR_ATTACHMENT1;
d.color_attach_2 = gl.COLOR_ATTACHMENT2;
d.color_attach_3 = gl.COLOR_ATTACHMENT3;
d.color_attach_4 = gl.COLOR_ATTACHMENT4;
d.color_attach_5 = gl.COLOR_ATTACHMENT5;
d.color_attach_6 = gl.COLOR_ATTACHMENT6;
d.color_attach_7 = gl.COLOR_ATTACHMENT7;
d.color_attach_8 = gl.COLOR_ATTACHMENT8;
d.color_attach_9 = gl.COLOR_ATTACHMENT9;
d.color_attach_10 = gl.COLOR_ATTACHMENT10;
d.color_attach_11 = gl.COLOR_ATTACHMENT11;
d.color_attach_12 = gl.COLOR_ATTACHMENT12;
d.color_attach_13 = gl.COLOR_ATTACHMENT13;
d.color_attach_14 = gl.COLOR_ATTACHMENT14;
d.color_attach_15 = gl.COLOR_ATTACHMENT15;
d.depth_attach = gl.DEPTH_ATTACHMENT;
d.stencil_attach = gl.STENCIL_ATTACHMENT;
d.depth_stencil_attach = gl.DEPTH_STENCIL_ATTACHMENT;
d.texture_2d = gl.TEXTURE_2D;
d.texture_cube_map = gl.TEXTURE_CUBE_MAP;
d.cube_map_px = gl.TEXTURE_CUBE_MAP_POSITIVE_X; xpだよ馬鹿
d.cube_map_nx = gl.TEXTURE_CUBE_MAP_NEGATIVE_X;
d.cube_map_py = gl.TEXTURE_CUBE_MAP_POSITIVE_Y;
d.cube_map_ny = gl.TEXTURE_CUBE_MAP_NEGATIVE_Y;
d.cube_map_pz = gl.TEXTURE_CUBE_MAP_POSITIVE_Z;
d.cube_map_nz = gl.TEXTURE_CUBE_MAP_NEGATIVE_Z;
*/

一応できました。これであとはfboを作る際に、infoの中でtarget:"cube_map"とすればOKです。
そして描画時にframebufferTexture2D(fboName, {target:"px"とか"nx"とかいろいろ})とすればOKです。
2dでも呼び出すことができ、{}が未指定の場合はそれが実行されますが、おそらく何も起きません。

そうだった。あそこはwとhが未定義でもいいようにするための処理だからfboの場合はどうでもいいんだったわ。忘れてた。
そうですね。それでいいですね。だめでした。srcが未定義の場合に{}にする必要がありました。ばかかっ

pxじゃなくてxpですね。たびたびほんとにすみません。pxやpyは別に役割がありますからね。

ほとんど変更点なかったですね...新しい関数作ったくらいですね。素晴らしい！！！
復習（何回でも復習）
            yp
zn -- xn -- zp -- xp
            yn
ですから、そういう感じでカメラを用意すればOKです。
upベクトルが上下逆ですね。まあー難しい。これは結局のところ、その、中央から外側に向かうので、...
むずかしい。

// -------------------------------------------------------------- いろいろありました ------------------------------------------------------ //
// 20241022

というわけで

mebiusboxさんの物理ベースを読んでみる

Lighting関連でもうp5っぽくやりたくない
ので
やめようかと
SpotLightとか機能してないし
ね、...

varying vec3 vViewPosition;
varying vec3 vNormal;

// uniforms
// 物体ごとのあれ
// metalicとroughnessと
// albedoはざっくりいうと物体の色で
// 今現在頂点色とか単色とかテクスチャでやってるやつって認識でいいと思う
uniform float metallic;
uniform float roughness;
uniform vec3 albedo;

// defines
#define PI 3.14159265359
#define PI2 6.28318530718
#define RECIPROCAL_PI 0.31830988618  // 未使用
#define RECIPROCAL_PI2 0.15915494 // 未使用
#define LOG2 1.442695 // 未使用
#define EPSILON 1e-6

struct IncidentLight {
  vec3 color;
  vec3 direction;
  bool visible;
};

struct ReflectedLight {
  vec3 directDiffuse;
  vec3 directSpecular;
  vec3 indirectDiffuse;
  vec3 indirectSpecular;
};

// ライティングに使ういわゆる「ビュー情報」
// 頂点ごとにこれが設定されており補間したうえでなんかする
// なんか、する
// このメソッドでpositionはビューから見た値

// じゃあ今はどうやってるのか？
// vViewPositionとvViewNormal
// そこまでは同じ
// こっちのvierDirに相当するものが無いですが...
// ああ一緒ですね
// z軸がカメラの方向
// というか「こっち」を向いてるせいで
// vViewPositionがマイナスになるので
// このコードではそれをマイナスにして
// カメラから見た場合の位置として扱ってる（z軸が逆方向になる）
// で、viewDirはそれを正規化する
// こっちでも最初の方で
// ライトベクトル作るために反転させて正規化してる
// 一緒ですね......一緒ですが、一緒だから楽ちん。とはいかない？
// で、それを全部でやってるのよね
// 無駄
// 正規化って大きさ計算するから重いのよね
// というかコードが汚いからやめようって話ではあるね

// 同じ結果になるように書き換えるということか
// ...
struct GeometricContext {
  vec3 position;
  vec3 normal;
  vec3 viewDir;
};

struct Material {
  vec3 diffuseColor;
  float specularRoughness;
  vec3 specularColor;
};

// lights

bool testLightInRange(const in float lightDistance, const in float cutoffDistance) {
  return any(bvec2(cutoffDistance == 0.0, lightDistance < cutoffDistance));
}

float punctualLightIntensityToIrradianceFactor(const in float lightDistance, const in float cutoffDistance, const in float decayExponent) {
  if (decayExponent > 0.0) {
    return pow(saturate(-lightDistance / cutoffDistance + 1.0), decayExponent);
  }

  return 1.0;
}

struct DirectionalLight {
  vec3 direction;
  vec3 color;
};

void getDirectionalDirectLightIrradiance(const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight) {
  directLight.color = directionalLight.color;
  directLight.direction = directionalLight.direction;
  directLight.visible = true;
}

// 点光源とスポットで色の減衰を計算している
// 場合によっては描画に反映しないと
// これ
// こっちでIntensityって出してる値がたとえばPointLightだと

// えー...とですね
// p5が悪いんじゃないんだよな
// p5を真似した自分が悪いのよ
// どうでもいいんですが

// あのですね
// positionをモデルビュー変換でviewPositionにして送る
// そこまでは良いんだけど
// ライトってグローバルでしょ
// そのままでは計算できない
// そこで、明らかに不自然なんですが、
// フラグメントシェーダにビュー行列を送ることで
// モデルベースのライトのベクトルをビューベースにして
// そうしたうえでビューベースのポジションと比べてライティングしてるんですよ
// 無駄。
// 無駄すぎる
// だってフラグメントシェーダよ？？
// ピクセルごとに...
// 全部内容が一緒のライトベクトルの変換をやってるわけ
// 無駄無駄無駄むだぁぁぁっぁぁ！！
// なことは最初から気付いてたけどな...
// この際だからな。やめよう。我々はp5を捨てるのだ。

// だからね
// 送るときにビュー行列を掛け算すればいい
// それでOK.
// 加えて正規化とか無駄が多い、処理に無駄が多いのでそこもちょっといじらないとまずいんだが
// この手の作業をディファードでもやってしまってる
// ただあれ
// 外面はいじらなくて大丈夫ですね
// あくまで内部仕様を変えるだけ

// というのがプランA
// プランBは？
// そういう仕様でPBRをとりあえず書いてしまう
// 書いたうえで
// 今現在のあれをそういう形にするのが現実的なら
// そういう風に書きかえればいい
// どうせライティング部分は切り離してあるんでそこまで問題にはならない
// 壊れることもない
// その方がいいかもしれないです

// 構造体使ったり
// ライトベクトルを先にビュー変換したり
// 色々違う感じになるけどまあ
// 何とかなるんじゃないでしょうか？？？

// 名付けて「PBRLightingSystem extends RenderingSystem」ですね
// システム的に
// ほぼ同じで...

// で、まああの...ディファードとかも考えないので、めちゃ簡略化されるかと...
// あとメソッド的には構造体とか使って全面的に書き直しますね。
// 基本的なメソッドは同じ感じでやります。
// ShaderPrototypeについてもPBRLightingShaderを一つだけ用意するだけでよいかと。

// 一つ聞いていい...attenuationって何。使ってないでしょこれ。
// 点光源とスポットライトで使ってるどうでもいい計算で...ねぇ
// mebiusBoxさんはどうしてるのか？
// まあここに書いてあるが
// 単純ですね
// 距離に応じて単一指数で減衰させてるだけ
// そりゃ逆二乗の方がそれっぽいのかもしれないけどこっちのがシンプルで分かりやすいわね
// 多分策定した人がなんか、気取ってみたかったんでしょ...（知らんけども）
// 。。。
// あれですね。
// メソッド泥棒しただけの人に発言権は無いのです。
// だから潔くp5を捨ててこっちになびこうっていうわけ
// p5wgexやろうってなる前からあの記事には目を付けてたんで
// こうなる流れだった。最初から。

struct PointLight {
  vec3 position;
  vec3 color;
  float distance;
  float decay;
};

void getPointDirectLightIrradiance(const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight) {
  vec3 L = pointLight.position - geometry.position;
  directLight.direction = normalize(L);

  float lightDistance = length(L);
  if (testLightInRange(lightDistance, pointLight.distance)) {
    directLight.color = pointLight.color;
    directLight.color *= punctualLightIntensityToIrradianceFactor(lightDistance, pointLight.distance, pointLight.decay);
    directLight.visible = true;
  } else {
    directLight.color = vec3(0.0);
    directLight.visible = false;
  }
}

struct SpotLight {
  vec3 position;
  vec3 direction;
  vec3 color;
  float distance;
  float decay;
  float coneCos;
  float penumbraCos;
};

// allとanyはbvec2（boolのvec2型）に適用する。要するにまたはとすべてですね
// あんま使わないが...
// スポットライトからポジションへのベクトルを正規化してスポットライト本来の....

// 点光源とスポットライトは点の位置も絡んでくるんですが
// 当然これらもビュー座標系で計算することになる
// で、
// positionがz軸逆方向で計算してあるので
// それを考慮しないと多分おかしなことになるわね

// え・・・
/// ？？？
// バーテックスシェーダで
//   vViewPosition = -mvPosition.xyz;


// まとめると
// まずviewPositionですが
// 最終的に2回マイナスですので
// 通常のビュー座標ですね...（つまりzが負の数になる通常の計算）
// んで
// viewDir
// もうここまで書いたらviewDirectionのが分かりやすそうだけど...
// これはマイナスにしたのをそのまま
// 正規化してるんで
// 点の位置からカメラに向かうやつだ。

// ダブルマイナスは分かりづらいんだがな..........


// えー、気を取り直して
// 何でこれを調べてたかというとね
// ポイントライトとスポットライトで
// 普通にその位置をモデルビュー、というか「点」なのでビュー変換してて
// だからおかしいなと思ってたら
// そりゃ2回マイナスしたら戻るわけだわ
// 逆にわかりにくい...lightDirだけマイナスの方がいいと思う
// 何かメリットがあるんだろうか
// まあいいか

// もしかするとzをプラスにしたpositionを別の用途で使う理由があるのかもしれないけどね
// 今回は不採用しましょ
// 一応

void getSpotDirectLightIrradiance(const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight) {
  vec3 L = spotLight.position - geometry.position;
  directLight.direction = normalize(L);

  float lightDistance = length(L);
  float angleCos = dot(directLight.direction, spotLight.direction);

  if (all(bvec2(angleCos > spotLight.coneCos, testLightInRange(lightDistance, spotLight.distance)))) {
    float spotEffect = smoothstep(spotLight.coneCos, spotLight.penumbraCos, angleCos);
    directLight.color = spotLight.color;
    directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor(lightDistance, spotLight.distance, spotLight.decay);
    directLight.visible = true;
  } else {
    directLight.color = vec3(0.0);
    directLight.visible = false;
  }
}

// #defineでライトの個数を決めることについて...
// いいと思う
// 構造体で扱うならその方が都合がいいだろ
// ていうか
// そんなのより
// shininessとattenuationって役割がかぶってるんだよな
// どっちも減衰を扱ってて
// はっきりいってめんどくさいんで
// やめたいです～
// 実際使ってないしな...

// ...ん？？
// DirectionalLightの減衰？？？？？
// 平行光なのに減衰？？

// こっちでクックトランスでやってるところ
// を
// 今現在のライティングでは
// フォンシェーディングでやってる
// そういう話だと思います...多分。
// じゃないな
// ランバート・フォンモデルだ。両方だ。

// FallOffってなんですか...

// あのですね
// 色を計算した後はやること全部一緒なんですよね
// つまり無駄が多い...

// 要するにこっちでRE_Directでやってるところを
// フォン・ランバートにすると
// 今現在のやり方に近くなるっぽいね。
// あとは今関係ないinDirectとか省いて
// いや一応残して
// それでいける？
// opacityどうするか
// 透明処理も一応（少ないけど）扱ってるんで
// ...
// albedoをvec4にしてalphaでopacityするか
// まあ気が向いたらで良いと思う
// よし。

// light uniforms
#define LIGHT_MAX 4
uniform DirectionalLight directionalLights[LIGHT_MAX];
uniform PointLight pointLights[LIGHT_MAX];
uniform SpotLight spotLights[LIGHT_MAX];

// ライトの数をユニフォーム変数として登録してるね。
uniform int numDirectionalLights;
uniform int numPointLights;
uniform int numSpotLights;

// ここまでだけを使うのであればおそらくだけど従来のライティングに...なる？

// BRDFs

// Normalized Lambert
vec3 DiffuseBRDF(vec3 diffuseColor) {
  return diffuseColor / PI;
}

vec3 F_Schlick(vec3 specularColor, vec3 H, vec3 V) {
  return (specularColor + (1.0 - specularColor) * pow(1.0 - saturate(dot(V,H)), 5.0));
}

float D_GGX(float a, float dotNH) {
  float a2 = a*a;
  float dotNH2 = dotNH*dotNH;
  float d = dotNH2 * (a2 - 1.0) + 1.0;
  return a2 / (PI * d * d);
}

float G_Smith_Schlick_GGX(float a, float dotNV, float dotNL) {
  float k = a*a*0.5 + EPSILON;
  float gl = dotNL / (dotNL * (1.0 - k) + k);
  float gv = dotNV / (dotNV * (1.0 - k) + k);
  return gl*gv;
}

// Cook-Torrance
vec3 SpecularBRDF(const in IncidentLight directLight, const in GeometricContext geometry, vec3 specularColor, float roughnessFactor) {

  vec3 N = geometry.normal;
  vec3 V = geometry.viewDir;
  vec3 L = directLight.direction;

  float dotNL = saturate(dot(N,L));
  float dotNV = saturate(dot(N,V));
  vec3 H = normalize(L+V);
  float dotNH = saturate(dot(N,H));
  float dotVH = saturate(dot(V,H));
  float dotLV = saturate(dot(L,V));
  float a = roughnessFactor * roughnessFactor;

  float D = D_GGX(a, dotNH);
  float G = G_Smith_Schlick_GGX(a, dotNV, dotNL);
  vec3 F = F_Schlick(specularColor, V, H);
  return (F*(G*D))/(4.0*dotNL*dotNV+EPSILON);
}

// レンダリング方程式
// 拡散と反射をそれぞれ処理してるですね
// つまりここにいくまでの段階では拡散も反射も考慮していないのだ
// ...
// 拡散は現在、ランバートでやっています
// ランバートというのは要するに法線方向と光の方向を見て互いに逆方向だと1で、ずれるごとに下がっていき垂直で0に、とかそういう。
// 反射は現在、フォンです
// フォンというのは光を法線で反射させて（綺麗に反射させて）、それが目線に来る、その、互いに逆の時1でMAXで、ずれると小さくなる、
// その時の係数がある、係数が大きいほど強く下がる、小さいほどなんかぺか～～～なる。
// この2つがこっちでいうところのDiffuseとSpecularなのかなと思いました。
// shininessですが
// RenderEquations(RE)
void RE_Direct(const in IncidentLight directLight, const in GeometricContext geometry, const in Material material, inout ReflectedLight reflectedLight) {

  float dotNL = saturate(dot(geometry.normal, directLight.direction));
  vec3 irradiance = dotNL * directLight.color;

  // punctual light
  irradiance *= PI;

  reflectedLight.directDiffuse += irradiance * DiffuseBRDF(material.diffuseColor);
  reflectedLight.directSpecular += irradiance * SpecularBRDF(directLight, geometry, material.specularColor, material.specularRoughness);
}

void main() {
  GeometricContext geometry;
  geometry.position = -vViewPosition;
  geometry.normal = normalize(vNormal);
  geometry.viewDir = normalize(vViewPosition);

  Material material;
  material.diffuseColor = mix(albedo, vec3(0.0), metallic);
  material.specularColor = mix(vec3(0.04), albedo, metallic);
  material.specularRoughness = roughness;

  // Lighting

  ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
  vec3 emissive = vec3(0.0);
  float opacity = 1.0;

  IncidentLight directLight;

  // point light
  for (int i=0; i<LIGHT_MAX; ++i) {
  処理はLIGHT_MAXまでとし、num～～Lightsで切ってるね
    if (i >= numPointLights) break;
    getPointDirectLightIrradiance(pointLights[i], geometry, directLight);
    if (directLight.visible) {
      RE_Direct(directLight, geometry, material, reflectedLight);
    }
  }

  // spot light
  for (int i=0; i<LIGHT_MAX; ++i) {
    if (i >= numSpotLights) break;
    getSpotDirectLightIrradiance(spotLights[i], geometry, directLight);
    if (directLight.visible) {
      RE_Direct(directLight, geometry, material, reflectedLight);
    }
  }

  // directional light
  for (int i=0; i<LIGHT_MAX; ++i) {
    if (i >= numDirectionalLights) break;
    getDirectionalDirectLightIrradiance(directionalLights[i], geometry, directLight);
    RE_Direct(directLight, geometry, material, reflectedLight);
  }

  vec3 outgoingLight = emissive + reflectedLight.directDiffuse + reflectedLight.directSpecular + reflectedLight.indirectDiffuse + reflectedLight.indirectSpecular;

  gl_FragColor = vec4(outgoingLight, opacity);
}

// vertexShaderは今まで通りで良いと思う
// viewPosition,viewNormalだけあればいい
// こっちで構造体用意してぶちこむ

// fragmentShaderはもうviewMatrixを受け取りません
// ライトのベクトルは送るときにviewMatrixで変換します
// 位置も...位置？？
// モデル変換にtranslateが関わってるからモデル変換もしないとまずいですね
// あーわかった
// あっちの「viewMatrix」って
// いいや
// 。。。
// モデルビューでいいでしょ
// 早く作りたい...

久しぶりのTODO
// ---------------------------------------------------------------------------------------------------------------------- //
TODO
20241024

まず
foxIAについて
登録したイベントというか関数に名前を付けて管理してピンポイントで削除とかできるようにする
たとえばwheel以外全部消すとかそういうの
名前はdefault_keydownとかそんな感じ
あくまでfoxIAが作ったイベントだけですね
今んとこinitializeでしか作ってないですからね
不要なイベントを削除出来たらうれしいなっていうのが一つと
あとまあ
ワンタイムイベント（一回だけ実行したらもう要らない）
次に
大きな変更になるんですが
mu...meshUtilのね、線とテクスチャ座標を

殺す

理由はいろいろあるんですが
まず
テクスチャ座標...要らんのです
ていうかあれ以来ほぼ全く使ってない
そもそもLSではオプションなのにmu.create()でやると普通にuvが入ってて
しかもcubeとかsphereとかやると使いもしないのにuvが設定されるわけで
しかもmu.regist()するとさ、使いもしないのにバッファにUVが....入るんで...
ていうかあれ
mu.regist()では頂点色は追加attr扱いなのにuvは必須になってるんよ
問題ないっちゃないかもだけど、まあ、無くていいかな、と思うなど...
そのかわりメタデータをつけるくらいはまあしてもいいかなって思うけど
たとえば？？
トーラスだったら角度とか
チューブだったらオフセットと主法線からなるvec4データとかそういうの。
uvではなく、メタデータ。あくまで。uvではなく。
uvでなくてもその、いろんな方法があるんでね。材料。
立方体も...？
まあそうね...
コンポジットの際に面倒なことになるのを避けたいんよ
たとえばサイコロ作るにしても平面をコロコロしながら作ればuvとか自由に作れるわけ
上下とかも結局
まあ例のあれ、水中動画、あれでやったように、上下とかカスタムしたいときに
普通に不便なんよ
テクスチャって通常Blenderとかでやるものでしょっていうのもあり
サイコロの他に思いつかないなら要らないだろって話
トーラスのカスタムUVにしてもそういうトーラスを作ればいいと思う
その場合はそういうトーラスを作る関数を新たに作って...
メタデータでやろう
というかまあ
そういう配列（円柱とか）作って
そのデータをそのまま使うかもしくはそれを元に好きなようにattrを作って
あくまで追加attrとして用意するなどすればいいしそれによって描画できればいい
トーラスで(cos(s),sin(s),cos(t),sin(t))
円柱で(h,cos(s),sin(s))
やりたいでしょ？そういうことですね。
lineについては、まあいわゆるワイヤーフレームだけども。
これも要らんのよね
必要になったら用意したらいい
とりあえず今は要らないんで
たとえば...
与えられた頂点から面の辺を重複なく用意して（Setとかで）それで辺を作るとか
対角線が問題だけどワイヤーフレームなら別に問題ないし
そういうこだわりがあるならまた個別にメソッド作ればよいかと...思うね。
だから全部削除してすっきりさせたい
っていうか
メッシュのコンポジットもっと自由にやりたい
頂点彩色でいいじゃない
UV？Blenderで作ってもちこめば普通に機能する、追加attrでやれば。それももう実験済みだし...
というわけでなくしたいです
頑張って計算したんだけど。全部無しで。
だいたい正二十面体だって諦めてて一貫性が無いし（気付いてたよ）
そういう感じでよろしく...！

foxIAの柔軟性を高める
具体的にはsignalとonceをすべてのリスナーに用意したい感じです
こんなことができるらしい

function setup() {
  createCanvas(400, 400);

  const AC = new AbortController();
  const removeSignal = AC.signal;

  const getPosition = (e)=>{
    console.log(e.clientX);
    if(e.clientX > 200){
      console.log("200より大きいので中止します");
      AC.abort();
    }
  }

  this.canvas.addEventListener("click", getPosition, {passive:false, signal:removeSignal});

}

function draw() {
  background(220);
}
ACを用意してそれのsignalを渡すことで
関数内でabort()を呼び出してそのイベントを抹消出来るようです
または
once:true
にすると一回だけ実行されて消える
これを使うと例えばあれ、クリックのイベントリスナーでdispatchして消す、とかできる
多分同じことしてるわね
もしくは
マウスダウンまたはタッチスタートで
どっちかで
たとえばね
AudioContextを生成して
どっちかで生成したらどっちのイベントも消える、とかしたい場合に...
onceだと片方しか消えてくれないので
この場合はabortですね！
touchstartとmousedownのそれぞれに
同じACから作ったsignalを渡して
同じ関数で...ってやればいいね
...click使いたくないんよね
dblclickで2回発動しちゃうし

abortとonceについてはこんな感じで実装できるかと思います。

/*
  イメージ的には...
	まずaborts={}というオプションを新しく作る
	中身ですが
	ctrl:["mousedown","touchstart"]
	といった感じで
	コントローラー名：[コントロールしたいイベント名一覧]
	のようにする
	んでその名前のコントローラを作り
	signalを取り
	そのイベントのところに来たら
	optionオブジェクトにsignalを登録する。
	あとは
	たとえばInteraction内で
	this.abort(コントローラー名)とかすると
	イベントを殺せるわけですね

  あとはそうね...
	once = []というオプションを用意する
	んで....
	単純にその中のイベントに関しては1回こっきりとする
	これもせいぜいmousedownとtouchstartでしか使わないが...

  initialize()内部のリファクタリングが要る
	具体的には
	仕様の中で登録するイベントを.mousedown={}とか.keydown={}とかとか
	{}の中身は
	{target:window/canvas, name:イベント名、func:関数、options:オプション（現在はpassive:falseのみ）}
	なんだけどこうすればoptionsに.signal:～～とかonce:true/falseとか追加しやすいでしょ
	今の形式だと無理
	んで
	それらが終わったら
	もちろん登録しないものについてはundefinedのままなわけ
	そうです
	で
	Object.keys()で取り出して
	ひとつずつぶちこむわけ
	ついでに関数も保持しておいて任意で消去出来たらいいんだけどとりあえず今は良いです
	このabortやonceにしてもどうせclickやmousedown程度でしか
	多分使う機会ないでしょうし
	ね。
*/
https://openprocessing.org/sketch/2412951

そうすると、たとえば5回タップするとイベントが終了するこんな感じのプログラムが書けるようになるわけ
function setup(){
	createCanvas(400, 400);
	const IA = new MyIA(this.canvas, {aborts:["mousedown","touchstart"]});
	background(0);
}

class MyIA extends foxIA.Interaction{
	constructor(cvs, options={}){
		super(cvs, options);
		this.count = 0;
	}
	myTap(){
		this.count++;
		background(50*this.count);
		console.log(`${this.count}回目のタップです`);
		if(this.count === 5){
			console.log("5回タップされたのでイベントを終了します");
			this.abort("ctrl");
		}
	}
	mouseDownDefaultAction(e){
		this.myTap();
	}
	touchStartDefaultAction(e){
		this.myTap();
	}
}
たとえば
メインインタラクションをInteraction継承で作っておいたうえで
コンテクスト作成だけIRにお任せして
IRのmousedownやtouchstartにコンテクストの作成とonceを要求して
さらに作成時のオプションで
mousedownとtouchstart以外のイベントを殺しておけば
すっきりするでしょ。そういうことがしたい。
そう
初期化時に特定のイベント以外全部殺すとかそういうオプションが欲しいんよ
不要なイベントを作らないために
restrict:[]
restrictに指定されたイベントがある場合、そのイベント以外はすべて作成されない！
[]の場合は用意されたイベントはすべて登録される
そんな感じですね
たとえば
IR = new Inspector(this.canvas, {once:["mousedown","touchstart"], restrict:["mousedown","touchstart"]});
これでmousedown,touchstart以外は作成されず、さらに両方とも1回だけ実行されるというわけ。
またaborts:{ctrl:["mousedown","touchstart"]}とすれば
これらのイベント内でIA.abort("ctrl")とすることで
任意のタイミングでイベントを殺せる
そういうのを作りたいです。

あとあれ

これはすぐできるんだけど
renderGradationのcolorsで長さ4の配列に限ってるけど
あれをcoulourに対応させるのをやろう。
renderTextureの方は対応してるんでね。

あともうちょっとだけ

PBRについて

noLightですが
やめよう
ライティングしないんだったら別のメソッドにした方がいい
初期化でライティング部分をバッサリ切って
別の形式になるようにする
もちろんmetallicとか一切なしの...
あるいはもういっそ
ライティング無しの別のPrototypeを作りましょ
そうしよう
その方がいいと思うんです

で
lineについても作って切り替えられるように...
ライトのヘルパーとか欲しい

opacityもオプションにする
これも常に必要なわけじゃない
ほぼ不要かと
ですね
必要な時だけ出現させてカリングと組み合わせるなどして
半透明描画でしょ？
そういうときだけ使えばいい
適用箇所はmainProcessのあと
rgbにopacityを掛けるかどうかも含めてこっちで決める。

以上です。両方切っといて。

切った。

とりあえずalbedoをvec4で渡すようにした
uAlbedoがvec4でalbedoがvec3(rgbを取る)なので問題ないですね

TODO
まずforwardLightingについて...ですが...
noLights()を廃止して
optionsでnoLight:true/falseとかする
デフォルトはfalse
つまりinitializeの段階でライティングルーチンをバッサリ切る
別のshaderにするのだ
LIGHT_MAX=4を採用する（5とか8でもいいけど）
上限を決めてしまう...
これも特に問題ないかと
5にするかな
で、ディファードはライティング前提なのでnoLightはそもそも縁がない
フォワードだけ
ライティングをバッサリ切る
別のshaderにする
要するにlightOn()とlightOff()がなくなるんで
それ相応の影響は出ますね

あー......
vNormalってそういうこと、か
たとえばvPositionのようなものか
つまり地球儀とかね
positionが変化した時にnormalが不変だとそれをUVみたいに使えるんよ
つまりむしろおかしいのはpositionの方か
そういえばvLocalPositionって使った記憶ないな...
要は、だ。
現在
vLocalPosition = position; vLocalNormal = aNormal;
となっているが、おかしいのはpositionの方なわけだ。
vLocalPosition = aPosition; vLocalNormal = aNormal;
こっちが正しいわけだ。
で、鏡とかに使えるだろうということで
normalDeviceCoordinateを用意する
postProcessにおいてvaryingで渡したりする
名前が変わるがそんだけだから。

materialFlagはLSの方はまあ頂点とか色々あると思うんで残すけど
PBRの方は敢えて用意しないでオプションとする（useColor,useTexCoordは用意するんで自前でフラグ立てたりしてください）
（いつものようにfsで分岐処理）

できればライトのシステムを全部PBRから逆輸入したい
仕様とか
んでライティングシステムを一新する
最終的にrgbを出すだけの処理なんで
構造体ユニフォームも出来てるし問題ないね
shininessは残るけどambientは多分廃止する,emissiveにすると思う

そうです
uUseLightをなくす
そういうこと。
lightOnとlightOffもuseプロパティもなくす。
noLightがfalseだと二重否定でわかりにくいので
useLight:true/falseにする

alphaについて
ほとんどの場合これは無意味である
ライティングにおいてアルファは基本的に必要ない
rgbにalphaを掛けるといってもalphaが1なら何にもしないのと一緒
なので
必要な場合はcolor.aをvec4の4成分として渡したうえで
mainProcessのあとでなんかする。
というわけで切ろう

半透明描画のスケッチが一つか二つあるけどまあ
何とかしましょう

光を当てるか当てないかが何を意味するのかって話
当てなければ暗くなるということ
そういう話

viewMatの廃止についてはちょっと待ってね
とりあえず不具合が出ないか見る...

あーdeferredもいじらないとまずいか
まあそうよね
片方だけuse無くしたら双方に影響出るわな
.....
directionとlocationをVec3の単独配列にする....
セッティングの際はコンストラクタというかsetに渡す引数を用意する
もし用意した分の方が大きい場合は新たにベクトルが生成される
最終的にuniformで渡すときに
必要ならuViewMatrixで補正が掛かるが
掛けない選択肢も用意する（便宜上！）
つまりもういちいちfrontを呼び出す必要はない
...

OpenProcessingあほだな
「,」が一個抜けてるだけなのに
クソみたいなエラー表示で覆い隠して分かんなくなってて
あほだ

まあいいや
さてと...


ライトもベクトルでやる
たとえば
[[0,0,1]]とか[[1,2,3]]のように指定する
複数の場合とかも
[v0,v1]などとする
コンストラクタを順繰りに並べる形

仕方ないです
p5のくそったれLightingに甘えてきたツケ
おそらくすべては直せない
いいよ別に
直せるのだけ直そう
あっちもこっちもだと疲れちゃう

ああああああ
uViewMatrixか
うぜぇ
まあいいや
...
まあlightingしないなら不要だしなこれ
だから排除したんだけど
そうなるとsetMatrixUniformsの方でもどかさないといけなくなるから
めんどくせぇ
いっそ今すぐ廃止してしまうのもありかな。うざいし。
p5のくそったれ...やつあたりなのは分かってるけど悔しすぎて気が狂いそう。

悔しい！！！！

ああ！！！くやしい！！！！
ていうか
shader内に現れないなら実行しなきゃいいんじゃないの？

というわけで仕様変更でshader内に存在しないuniformについては
実行スルーにしました
もういいよそれで
まあ
strict modeとか用意して
そういう場合はエラーが出る、とかしてもいいかもだけど。

いずれ
uViewMatrixはfsで受け取らなくなるんで
それまでの応急処置でもいい
あとからなくすことは可能

応急処置です。

さてと。uViewMatrixやめよう。
で
ライトとポジション？locationを、ベクトルの配列とする。
入力は後方互換性のために数の配列を許す
[1,2,3] -> [[1,2,3]]
[1,2,3,4,5,6] -> [[1,2,3],[4,5,6]]
のように変換して扱う
それとは別に
v, [v], [v,w], [[1,2,3],v]
のような書き方もOKとする
つまり長さ1以上だとして
0番がtypeof number の時とそれ以外で分けて
それ以外の時はすべてコンストラクタ扱いとする

uViewMatrixが殺せたかどうか調べるためにデモを作らないといけない
例の立方体ですね
...できるんかね。

cameraBaseやめよう。オプションにしよう。
で、infoやめてparamsにするか
どのみちPBR入れようってなったらここは構造体定義になるし
そうなると
paramsはそのままぶちこむことになるわけで...
(params={}, options = {})の方がいいね。
で、optionsの中でcameraBase:trueって書けばいい
色々すまんね
...よろしく....

なんかやることあった？今あたまがからっぽでよくわかんない
...
まあいいや。早く寝よ。
ああーそうか
構造体の入れ子？だっけ
いいよ必要になったらで
今別のことしたい

とりあえず一段落だしな
まあ
休もうぜ
meshUtilからuvとlを排除するんだっけか
そんで...


すごい
何もやる気しない
こういうときは日記を書くに限るね

shadowはくだらない凡ミスが原因でした
ごめんなさい

多分光学迷彩と射影テクスチャマッピングとあと動的キューブも
何らかの形でバグってるけど
直すの簡単だから
のんびりやりましょ

TODO
meshUtilをどうするかの問題
決着
あのですね
uvは廃止です（廃止です）（廃止！！！）
で、lについて
コンストラクタで一応this.l=[]
するんですが
wire:true/falseのオプションで付けるかどうか選びます（現時点のメッシュすべて）
compositeについては
いずれかのGeometryがlを持たない場合に限り
lを持っていてもそれについてはコンポジットせずデータを破棄します
lを持たないGeometryになるということです
さらにregistMeshでuvを必須から追加に格下げします
つまりaTexCoordを使いたければ追加attrで宣言する必要があります
これも微妙に影響を及ぼしそうです
まあそこまで大きな変化では無いので大丈夫でしょう...
例のメッシュ紹介ページでは
uvをやめて単色にしますね。それで。

動的キューブてんやわんやでしたね
同じライトを複数のカメラで取り扱うのは想定してなかったです
setLightingUniformsで補正掛けないとだめ
全くその通りですね

とりあえず一段落（noLightとuViewMatrixの討伐作業）
これからメッシュ作製関数のUVを討伐する旅に出ないといけない（大変）

PBRですが
おそらくその、パンクチュアルライトにしても、ラインシェーダにしても、
共通するコードがかなり多いんですよね
まあでも別に作るよ。

ブレンド復習

blendFuncSeparate(srcRGB,  dstRGB,   srcALPHA,   dstALPHA)
このときどうなる？？？？

4つの引数はvec3もしくはfloatである

srcRGBcolor * srcRGB (+) dstRGBcolor * dstRGB ---> RGBの色（値）
srcALPHAvalue * srcALPHA (+) dstALPHAvalue * dstALPHA ---> Aの色（値）

だからたとえば+,ONE,ZEROなら「+,ONE,ZERO,ONE,ZERO」だから上の色（値）がそのまま落ちる。
じゃあ下の色、というか値に上の値を一律に掛け算するにはどうするか？
「+, "dst_color", "zero", "dst_alpha", "zero"」でいいはず。そんでソースを「m,m,m,m」にすればいいはず....
multiplyはalphaを考慮しないといけない都合上、単純な内容にはなっていないが、
フロートの値を扱うのであればこれでいいはずです。
ちなみに単純に値を加えたい場合はADDがそのまま使えます（"one","one"）
あとセパレートでなくても単純に「+, "dst_color", "zero"」でいいはず。（なんならプリセットに加えてもいいけど）
これを使えば-1を掛けたり31/32を掛けたりできるはず。

うーん
閾値以下だと0、は無理っぽいね
このコードでもおそらくそれはやってない
特に問題ないのでは？
テストコード書いて確かめるしかないか。

今はインスタンシングあるからフロートテクスチャのテスト書きやすくていいね
当時は大変だったからね(2021/11くらい)
そういうの無かったんでね
...
別バッファ用意すればできるよ。けれど、
閾値以下の時に0にしたいってだけの理由で別バッファ用意するのは無駄に思えるからな。
あったほうがいい？


今日はここまで。



さすがにもうやめるか。
でもまあよくPBRまでやったよね...これでいいよもう。

アドカレ：p5wgexデモ集
内容（予定）
インスタンシング
鏡反射
キューブマップ
環境マッピング
動的キューブマップ
フォグ
トランスフォームフィードバック
バイトニックソート
PBR
射影テクスチャ
ピッキング（色変え）
ピッキング（オブジェクト移動）
せいぜいそんなところ。もうやったやつばっか。新しいのは無いです。
それに作ったところでどうしようもないのばっかりだしな

ピッキングによるオブジェクト移動はGPUカメラなんか要らないと思います
どういうことかというと
タッチとかする際にその位置の色を1x1に格納して
別に用意した1x(ポインタ総数)にフラグとして落とせばいい
あー...1x(オブジェクト総数)の方がいい？落とすのはポインタの番号かなぁ整数？（マウスなら-1しかでない、これを0とするとか。）
マウスダウンの際に毎回なんか落とす、空振りでも落とす。パッキングの経験を生かす。
整数化して添字とし、moveDataにアクセスすればよさそう。
マウスリリースでも同じことをすればフラグを消せる
フラグが立ってるかどうかTFFのvsでチェックして立っている場合に同じ添数のmove amountに従って位置更新すれば
GPUとCPUのデータのやり取りを一切介さないで動かせる

そして
だから何って一蹴される。
そういうことですね
人生の無駄

スマホとデスクトップの挙動の違いとかほしいかも

this.attrs = [
  {type:"vec3", name:"aPosition"}
];
this.varyings = [
  {type:"vec3", name:"vLocalPosition"},
  {type:"vec3", name:"vGlobalPosition"},
  {type:"vec3", name:"vViewPosition"}
];
this.vs.precisions = ``;
this.vs.constants = ``;
this.vs.uniforms =
`
  uniform mat4 uModelMatrix;
  uniform mat4 uModelViewMatrix;
  uniform mat4 uProjMatrix;
`;
this.vs.routines = ``;
this.vs.preProcess =
`
  vec3 position = aPosition;
`;
this.vs.mainProcess =
`
  // 位置と法線の計算
  vLocalPosition = aPosition; // aPositionの方が使えるだろ。ていうかローカルってそういう意味よ
  vGlobalPosition = (uModelMatrix * vec4(position, 1.0)).xyz;
  vec4 viewModelPosition = uModelViewMatrix * vec4(position, 1.0);
  vViewPosition = viewModelPosition.xyz;
  // 法線関連はあとで加えるので

  vec4 normalDeviceCoordinate = uProjMatrix * viewModelPosition; // あった方が便利なので
  gl_Position = normalDeviceCoordinate;
`;
this.vs.postProcess = ``;

this.fs.precisions =
`
  precision highp float;
`;
// fsのpostProcessは個別でいいや
// 共通に書けるのはせいぜいこのくらい。あとは個別処理に任せましょ。

// おわり。
