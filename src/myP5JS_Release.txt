myP5JSの更新履歴
少しずつ変えていって
スマホ依存バグの原因を突き止める。

手始めにimageを2Dに特化させる

線のグラデーション導入しました
変化なしです
んー...

ここまでは大丈夫。あと2つですかね。
ベジエとクワドラは後回しでいい。先に面の方。これは変えるところが少ないので...
問題ないはずなんだけど...
テスト項目はまあ、もう知ってると思うけど、頂点色ライティング、ジオメトリの頂点色。とりあえずこの2つ。
というか自分で用意した6つ全部？あ、もうあるわ。これ全部試せばいいのね。

testおわりました～
pushおわりました。さて、どうなるか...
どうなるかなぁ

はい。消えました。やっぱね。
これが原因だ...
とはいえ...どうするかな。
スマホでしか起きてない以上、プログラム内のどこいじればいいのか、ねぇ。むずかしいよね。

ちぇ。
まあ、戻せばいいんだけど。
shaderかなぁ。でもshader戻すのかったるいな。一旦...uniformにしてみる？あるいは...
甘かった場所があるんだろう。

原因判明しました。スマホの方、頂点色でエラー出ますね。
頂点色実装後にエラーが出ました。パソコンでは出ません。
リリース前に直さないとえらいことになりますね...
パソコンでは出ないってのが厄介。やばいね。
imageの中のあそこをいじればいい、begin～endShapeの。ということは、おそらくあれのUVの...
メインの方はshader分岐はいじってないんですよ。あくまで、あの、フラグ渡してるだけで。フラグ？
単色か頂点色かってとこです。プリミティブが消えますよね。おそらく何かしらの影響で何かしらのフラグがオフになり、
その後trueにする機構が働かなくなる。そのあたりかと。

そうですね。uvが絡むbegin～endShapeが原因ですねぇ。これがあると、何らかの...
色が黒くなるなら背景のところにちゃんと黒いシルエットが映る、それが無いということは色の出力が無いのではなく...
たとえば？texture描画になっているがtextureが使えないので表示されない、とか？

そういうわけです。どうしようね。

透明度が0だと表示されないので透明度が0になってる可能性があります。
使われているのがphongShaderなのは間違いないです
そこで
一旦これを単色シェーダにします
今のスケッチの場合影響はないです。
これで様子を見ます。

なんなら真っ白とかでもいいんだけどね

ビンゴですね
なくなりました
というわけであそこなぜか知らないけどフラグが戻らず存在しないはずの頂点色が使われてしまっていますね
それで透明になってしまったようです
なぜ？スマホだけフラグが戻らず？しかもなぜimage関数内のbegin～endShapeが？関係してしまっているのか？？
なぜあそこをgeometryにするとうまくいくのか？geometryの描画にはRetainedが使われている。begin～endShapeはimmediateだ、で。
それがなぜプリミティブの描画に関係してくる？フラグの重複？レンダラーの...レンダラー？共通？？
すべてRetainedで揃うから、か？すべてあのフラグはfalse.
そして...immediateではあのフラグは常にtrueで...だよね。常にtrue. でもtextureがあればtextureが使われるのだ。そしてtextureが無い場合に
頂点色と単色の二択になるが、その際あのフラグが立っているとそっちが優先、しかしそれは、...計算されるからさぁ、...？？
shader取得前に計算されるべ？そこになんか入ってて、そのせいで、フラグが立ったまま...

えーーーーと。
あれ？
スマホ依存バグ...あれ？？

バグ出ました
というか、んー、？？

グラデーション正方形を追加したら
それ以外のプリミティブがすべて消滅しました
しかもimageを使っていないにもかかわらず、です。？？？
おそらく、まちがいなく、uUseVertexColorがtrueで描画されてるんですよ、ね。うん。...
違いますね
あそこがaVertexColorになる場合の見た目は灰色っぽいんですよ
とはいえあそこがuMaterialColorだと問題は生じない...となると原因はFragの方か？

isTextureがtrueであるがゆえにnullで...
となるとisTextureか？あれがなぜかtrueで...？
それも違う。そういう見た目じゃない。原因は...？？？消える？shaderが実行されていない？ドローコール自体が？

そういえばグラデーションのプリミティブは普通に描画されていますね

背景や文字を表示しないようにしてもだめでしたね。ん？

デフォルトをfalseにしました。それでもスマホだと、消えますね。はい。何なんだ...
パソコンでは相変わらずすべて描画されます。どのフラグを見ればいいんだ...

今スマホで調べたら最初のループでは4つ全部描画されますね。2ループ目以降で表示されてないです。
最初のループの後なんかあったみたいです。_updateでなんかいじる必要があるか？
まあこういうバグはよくあるんだけどね...おそらく迷路のあれも最初のループは表示されるのでしょう。んー...
つってもフラグ立てて普通に描画してるだけだが...？

あ、そうだ、なぜかplaneには影響ないんだよ。何で？？planeだけ影響ないんだよな...
はい。noLoopで最初のループだけにしたらtextureついたgeometryの描画の後boxが消滅してますね。だんだん輪郭が見えてきました。
つまりvertex colorの付いたなんかを描画すると（それがplaneであったとしても）そのあとの
なぜかplaneではなくboxとかtorusが消える、しかもスマホだけで。そういう謎の現象が起きているようです。

planeとboxたちの違いは何なのか、またなぜ頂点色の付いたgeometryを描画するとやばいのか。
begin～endでなんか描画するのも頂点色描画だから同じことだ。同じこと...スマホの最適化か？あれか？前にも遭遇したが...

つまりtexture云々はあまり関係なくて、...ということ？はい。そうです。textureは関係ないです。
というわけで、はっきりしてきました。まず、現象は頂点彩色のimmediateもしくはretainedを描画した直後に起こると。で、
考えが浅かったな...しかしドローコールは実行されているのだろうか？
planeに影響ないのも不可解。

頂点色の...消えないですね。
頂点色ならboxでも消えない...というかboxというかポリゴンですけど。
んー。んーー？？つまり、vertexColorsになんか入ってるやつをRetainedにせよImmediateにせよ一回でも描画すると、以降は
vertexColorsに何も入ってないやつらはすべてアウトになる...？？それはRetainedの...もしくはtextureもか。textureであそこがすっからかん。それもだめ。
そういうの以外、一切描画できなくなるみたい。Immediateは常にあそこなんか入ってるからね。...Immediateは常にそうなのよね...texture使う場合でも...
ていうかtextureはあれ、vColorを頂点色にしたうえでtextureのが採用されるのよ。

そうですね。単色描画しようとしてるやつらは軒並みアウトになってます。どゆこと。planeも？
planeも単色描画だけど描画されるべ。ああーーー！！

仮説は正しいようです。スマホだと、一回でもvertexColorsになんか入ってるものを描画すると、それ以降はvertexColorsがすっからかんの
オブジェクトはplaneを除いて一切描画されなくなります。なぜplaneだけ描画されるのか？？調査中です。
imageが悪いのではなくてその中で...ん？
あ、なるほど。
あのプログラム、「vertexColorsに何か入ってるやつが一切出てこない」んだ。平和な世界。それで全部滞りなく描画される。
つまり。
スマホ依存のバグ、未解決！！！何にも解決してなかった！

もし。
もし、vertexColorsに何も入ってない場合...単色かtextureの二択になるわけだが、
その場合仮にvertexColorsに単色がみっちり入っていたとしても
それって同じ結果になるわけですけど
それでもtextureがあればそっちが優先されるので問題ない
問題が生じているのは今のところ「RetainedModeのvertexColorsがすっからかんのジオメトリー」ですので。
だからあそこで「0の場合は単色で埋める」ってやれば問題ない？？どっち？Retainedだけ。
strokeでも同じ問題が生じてそうで怖い

というわけでdrawBuffersのdoFillのときの処理を

if (geometry.model.vertexColors.length > 0) {
  this._useVertexColor = true;
} else {
  this._useVertexColor = false;
  for (let i = 0; i < geometry.model.vertices.length; i++) {
    geometry.model.vertexColors.push(...this.curFillColor);
  }
}
// こうするの？？とりあえずこれで試してみる。
//this._useVertexColor = (geometry.model.vertexColors.length > 0);

こうしました。結果、意図的にvertexColorsの中身を空にしたgeometry以外はすべて描画されました。スマホでも。
たしかにうまくいったので何かが、何かが良かったようです。
しかしあれの場合は...

vertexColorsの中身が空のgeometryに対してはなぜかこの方法でもだめでした。なぜ？？？？

それと最終的にこの案は破棄しないといけない
なぜならvertexColorsに色を入れないということは、単色で彩色するということ。
つまりその「単色」が自由に変化させられるということ。
なので、固定できないんだよ。後で変えられなくなる。だからできない。

もっというと...まあいいんだけど。geometryの構成でvertexColors入れちゃうとその瞬間に
単色彩色が一切できなくなるのもほんとは駄目なんだよ。それもまずいわけ。ただ今の貧弱なシステムだと
そこら辺いじるのがとてつもなく難しいのよ。

うん、色の変化に対応できないので却下です。

0の場合は描画時だけcurFillColorで満たして、それが終わったら戻す、とか？でもmodelに影響ないの不自然だよね...スマホだけ影響ないとかマジで不可解

気になるのはこれがimmediateModeの頂点色描画でも生じるってことよ。

...

なんていうかもう、機種依存とかじゃなくて、ただのメモリ不足のような気がしてきた。
もう挙動がおかしいどころじゃないのよ。curFillColorはなぜか上書きされないし、表示されてたオブジェクトも消えるし、
セオリーが通用しない。もうめちゃくちゃ。めちゃくちゃなのよ。大体
プログラム通りに動かない時点で意味不明なのよ。だめだ、もう。

modelの場合、頂点色が入っててもだめみたいです。だからあの方策が通用しなかった...？？
いや、何か入ってる場合にあの方策を利用するとOKみたいです。どゆこと？

メモリ不足ではなく機種依存バグです。間違いなく。

Retainedの方のフラグを折ってみる。

フラグ折りましたが影響消えなかったです。falseにしてgeometryの方vertexColorsが反映されないようにしても
それ以降の単色プリミティブは見事に消えてしまいました。何で？しかもスマホ限定で。はぁ？？？

ImmediateとRetainedは同じshaderを使っている。Immediateではフラグへの代入はendShapeでしかやっていない。
同じshaderを使ってるせいで問題が生じている？違う。だって今回immediateは不使用。となると...
仕様変更でphongVertの方、vColorをuMaterialColorにしたら問題が消えた（もちろん頂点色も消えた）
あれで問題が消えるの冷静に考えたらおかしい
おかしいんだよ。
いっそaVertexColor限定にする？か？

もしくは

頂点色＆ライティングの場合だけ違うshaderを使う...？フラグで分岐させるのではなくshader自体違うものにしてしまえばいい？

とりあえず再びuMaterialColorにして様子を見る...

verexColorPhongVert
vertexColorPhongFrag
あと2種についても同様に

shaderいじったら単色プリミティブすべてOKになったんですけど
あっちの方はmodelが変なことになってますね

あれtextureのbox以外全部phongVert--phongFragで描いてるからすべてに影響が出てるんですけど
まずいみたいですね

というわけでもう一度、今度はフラグも折ってみるか
もうひとつ
phongVertからuniform bool uUseVertexC

bool？？？
そういえばboolまずいんだっけか
・・・
uniform bool uUseVertexColor外してみる
今使ってないし
boolはあれ、まずいのは配列だったと思う。確か。
これで様子を見る...

だめですね。
setUniformもなくすか。それでまた様子を見る。
しばらく待って反映されないようならimmediateの方のフラグもfalse...ってもう影響してないんでしょ
全部phongVertで描画してるんだから
どこいじればいいのよ
ていうか
もともと問題発生してたってこと？？
それともvertexColorsになんか入れる行為自体がもうなんか、タブーというか、そういうこと？？

aVertexColorも排除して。宣言がどう影響するのかしらないけど、なにかしら、あると思うので。
というかもうそこしかいじれないのよ。これいじったらもう、少なくともphongしか使わないなら、以前と一緒になってしまう。
それとも以前からあった問題なのか？それとも...
lineと同じ変数名なのがやばいのか？？？？それはあるかもしれない...？？shader違うのにそうなのか？？？？
いやlineつかってないやろ
一旦前の状態に戻します。もうわからん。
大丈夫。fill関連のshaderまとめて戻すだけだから。？
そういえばvertexStrokeColorとvertexColorがどちらも同じ名前のaVertexColorって変数に紐付けられてるわね...これまずいのでは？
lineの方でaVertexColor使ったのやっぱまずかったか...？aVertexStrokeColorに改名すべきかもしれない。それか？
あれはこっちもなんかやばいなって思ってたんだよな
でも...
スマホ限定のバグがそんな簡単に直るもんなのか？

aVertexColorだめ
はい
戻しましょう

全部戻したよ。
単色描画はできるようになったしおそらくimageもできる、できるんだけど、
modelの方、1つまでしか描画されないですね。
どうしますか？

線のグラデーションは改変箇所多すぎて対処の仕様が...ていうか
線でしょ？関係ある？？
それ以前のあれこれはshaderいじってないからおそらく無関係なのよ。
だから可能性としてはさ
う～ん
だってfillなのにstroke関連の仕様変更がどうして影響するのよ

fillなのにstrokeの仕様変更が影響するの？
これだけ時間たったら反映されるだろ
はい。strokeの仕様変更の時点で問題は起きてましたね。どういうこと？

線のグラデで問題起きてるなら全部やり直すしかないわね

あのですね
1.5.0でもだめですね。？？？
黒背景だと黒いときに消えちゃうので灰色がいいですよ

黒いだけで見えてた
ということです

4.2→5.0のときlightingの仕方に変更があってそれで真っ黒が真っ黒でなくなった
あれたしかambient辺り？それでこうなったっぽいね。
んー
1.5.0にも問題があったの...か？

1.5.0の状態でも2つ目以降のmodel消失確認できました
スマホだけです
パソコンは影響なし
つまりこのバグはもともと存在していたのよ
こっちの独自仕様変更とは別に存在していたということ
それが
ああでもshaderでuUseVertexColor使って処理分岐させるのやめたら単色に関しては復活したんだよな
でも1.5.0に起因するバグは解消されなかったわけだ。
つまり
model消失とstroke gradationはおそらく無関係で
----
単色消失バグがvertexColor gradationによる影響で
model消失バグが1.5.0に起因するもの、
----
という認識でよさそう

どうしろと？？
だから線のグラデーションを諦めてもmodel消失バグは消えないのよ
もう検証済みだけど

-------------------------------------------------------------------------------------------------------------------------

一旦ご破算にしました
ゼロに戻しました
2023/01/18

で、今どういう状況かというと
drawBuffersのところにパッチを適用しました（内部仕様の変更、及び新たなるShader関数の追加）
さらに
bezierVertexだけ頂点の色補間を導入しました（ratioを使った簡易的なもの）
これは特に意味はなくて、きちんとコミットされているかを試すためのものです。
2023/01/21

今から頂点色補間をライティングに適用したいと思います。
それで真っ黒になるバグを回避できるか調べます。
ここで真っ黒になったら...もう、お手上げですね...ゲームオーバー...
_bezierにパッチ当てると真っ黒になるの原因不明ですが、
ああいう事実がある以上、安易にパッチの適用を打診するわけにはいかないんですよね
困ったね。泣き寝入りするしかないのかも。

見ましたよ。プルリク。
プリミティブどうする的なことは書いてありました。懸念はされてたようです。
しかし多分ですけどこのスマホ特有のバグの話とは若干ずれていますね（機種依存の話とかもなかったし）
んー...
速報！
2月に1.6.0がリリースされます！！
やばいいい！！
とにかくまずは頂点色ライティング実装しよう。落ち着いて！！
下手したらとんでもないディストピアになってしまう可能性...ひぇぇ

実装...されました...？？
真っ黒になってませんね。
本当に実装されたのかどうか。
ライティングしてもあれが消えないのかどうかを
確かめないといけない
別のテストにします
2023/01/21

成功ですね。どっちもグラデーションついてます。
まあ、これが正常ですよね...だからなんとしても
直す必要があるんですよね。
さてこれどうする？コミット、する？？

スマホの方確認してきました
OKです
ライティングありでも頂点色ライティング機能しますし
さらに
スマホでもsphere消えません！！
大勝利！！
通さないと...


再びバグが発生したのと、結論も出ました。
レジスタの共有
まあいろいろな問題が発生するようです

今日直面したのはimage()を使った後でライティングをやめてテクスチャもやめてなんか描画するとおかしなことになる
というもの
まあライティングなしで球とかトーラス描くの不自然だけどね...
それはおいといてね
aVertexColorが他のshaderにより有効化される
そういう理解だったんですけど
違くて
shaderAとshaderBがあるでしょう
どっちもaVertexColorを使っているんですが
いまsphereを・・これaVertexColor持ってないわけです
これをshaderBで描きたい
その際shaderBにおけるaVertexColorに該当するレジスタが有効だとまずいので無効化したいんですが
そういう意図でパッチ作ったじゃないですか
でもあれが機能しないわけです
だってshaderBがaVertexColorのレジスタ番号のレジスタが有効化されてることを知らないから
shaderAが有効化しました
aTexCoordを2番に入れて有効化したんですよ
それが残っちゃってるわけです
で
その番号こそ無効化したいのに
今のパッチはその番号を特定できないので
無効化できなかったんですね
そこで頂点彩色独自定義ジオメトリーの出番ですよ！
これは確実にaVertexColorのレジスタを有効化してその履歴を残します
ですから
そのあとのsphereなどの描画ではその有効化の履歴に基づいてレジスタを突き止めて無効化できるんです
が
そんなことしなくても直接無効化できないのか？
できます
レジスタ番号ごとに有効かどうかの情報を
レンダラーが保持して
その情報を使えばいいんですよ
結局のところ、shaderAがどうこう、という話ではなくて、レジスタ番号2番が有効化されていることが
問題だったってこと？じゃあ他の何かでもいいんだ？それこそ普通にライティング球でも？何でも...？
えーと...頂点彩色云々でなくても？？ってことになるけれど...
immediateで頂点色使うからとかそういう話でもなくなるな...だって「2番が有効化されている」の事実がすべてなんだろ？うーむ。
違いました～～～～

となると
あの正方形2つのデモ
まああれは同じシェーダーで描いてるからな...

単にレジスタ番号どうこうって話でもないらしい？？？もうわからん！！！！
もう一つの条件を満たしてないからだよ
レジスタ番号が有効化されており、なおかつ....の、それ。
単に有効化されているだけでは描画エラーにならない、当然だけど。そこに...

アイデア
Renderer.GLにregisterEnabled = [];で配列を用意
次に有効化するたびにそのlocにtrueを入れる
disableのところで「有効化されている」の代わりに
「ロケーションのレジスタが有効化されている」を使う
シェーダーがもともと無効化しているなら、問題はないし
有効化していたとしてもこの描画でそれを無効化する必要が生じるなら
その番号のロケーションは有効化されているはずだから
シェーダーのenabledは見る必要が無い
で
そのうえでジオメトリに入ってなければ無効化する感じですかね？
で
フラグも折ればいいわね。enabledもfalseにする。

おそらくうまくいくんだろうけど
うまくいかなかったらもう
色々諦めるわ
p5.jsで作るとかそういうの全部
もう疲れたので

あー、できました。
できました～～お疲れさまでした～～これが正しいパッチですね。
ほんまか
わからん
経過観察や
どんな変更をしたのか？shaderの関数を追加して、ジオメトリの「持ってる」attributeの一覧を作って、それを渡して、
locationごとの有効/非有効をチェックして、有効なもので不要なレジスタを無効化する。そんだけ。無効化したらきちんと記録する。
そういう感じですかね。
パッチがこれでいいのかどうかは知らないです。
今後
・線の色補間を実装する
・色々テスト（6つの補間も含めて一通り）
・ベジエとクワドラにも補間を実装
・例のメッシュが消えなくなることを確認
・そんなところ？

おはようございます

disableUnnecessaryAttribは要らないですね
_prepareBuffer内部でデータを持っていないところの分岐を書き換えればいいんですよ
そこでシェーダーが持つattrかどうか判断すれば最初の選別ができるじゃないですか
後は一緒
こっちの方が処理が簡略化されるはずです
で、レジスタが有効になっている場合はオフにすればいいんですよ
つまりdrawBuffersは「一切書き換える必要が無い」
で、_prepareBufferだけ書き換えればいいんです。多分ね...

_main.default.Shader.prototype.disableUnnecessaryAttrib = function (geomAttrNames) {
  const attributes = this.attributes;
  const gl = this._renderer.GL;
  for(const attrName of Object.keys(attributes)){
    const attr = attributes[attrName];
    const loc = attr.location; // 先にlocationを取得
    if(!this._renderer.registerEnabled[loc]){ continue; } // レジスタが有効でないならスルー
    //if(!attr.enabled){ continue; } // shaderが有効にしていなくてもレジスタが有効になってる場合があるので、条件を変える
    // 有効なattrで
    if(!geomAttrNames.includes(attrName)){
      // geometryが持たないものを無効化する。
      //const loc = attr.location;
      if(loc !== -1){
        gl.disableVertexAttribArray(loc);
        attr.enabled = false;
        this._renderer.registerEnabled[loc] = false; // レジスタの有効状態を記録
      }
    }
  }
};

うん、全部網羅してるね...shaderが使うものは全部出てくるはず。fill限定だけど。fill限定だからfillのものがすべて出てくるわけだ。
だからshaderの持つそれも当然出てくるよ。
shaderが持ってるかどうかは!attrで判断してるよ
だからこれを潜り抜けたattrというのは操作したいattrをすべて網羅してるはずだよ。
そのうえでジオメトリーが持っていない（if not 分岐）
のであればこれですべてのはず
うん
あれでいいんじゃないかな？
this.attrの方が範囲が広いのですよ（出てくる可能性のあるものすべて、fillなら5種類）
これしか出てこないわけです
まあimmediateとretainedで若干違いますが...
今対象にしているのは全部出てくるはず
shaderが持っていて、ジオメトリーが持っていない。そしてその場合ロケーション番号が-1であることはあり得ない。
shaderが持ってる以上0以上のなんらかの整数値が割り当てられている。まあ一応調べるけどね。
んで失敗したらあれする。うん。
書き換えるところが少ないほうが通りやすいしな。
しかし
問題は_prepareBufferでこれを行うとなるとRetained以外のバッファ操作にも影響が出るということなんだが...
まあ、問題ないか
immediateの場合ほぼ全部用意されてるし
そもそもジオメトリーが持ってないんだからdisableしたところで何の問題もないでしょう
必要なものはすべてenableされるのです
必要ないものがdisableされない今までがおかしかっただけ

というわけで_prepareBufferだけ書き換えましょう
実験が必要ですが...
まあ
今どういう状況かというと
drawBuffersで配列作って関数実行してる
あれをいったんやめて（コメアして）
_prepareBufferのif not分岐に
今言った処理を書いてコミットして
様子を見ます
--------------------------------------------------------------------------------------------
間違ってたら戻すけどね。これでいいと思うんだけど、自信ないわね。
どうやら正解のようです。おつかれ！！
ってわけで、
1. RendererGLに registerEnabled = []; を用意
2. enableAttribで registerEnabled[loc] = true;
3. _prepareBufferでif分岐のnotにおいてlocを見てregisterEnabledをチェックして
   falseなら何もしない
   trueになっていたらdisableを呼び出して無効化する
   ついでにフラグも折る
   ついでにregisterEnabledもfalseにする
たった、これだけ。たったの...これだけ。
迷路のメッシュもOKです。

えー、さきほど
まあそういうこと
まず
registerEnabledは廃止して
vertexCountか。それを使って0で埋めましょうってわけね。
めんどくせ
disableの方が圧倒的に楽でしょ...メモリもったいないやん
スマホに何させるつもりなの？
データ用意するの無駄やん
なんかまずいの？disableなんかまずいの？？？？

今見てきたけど
RenderNodeはenableだけですね。disableしてないです。
shaderが持つattributeで使わないものは...まあ、基本そういうの用意しないからなぁ。
てかあの一件以来注意してるし
てかそれ以前にこっちでshader選べるからな。問題起きようがないんだよな。

というわけで
disableにする方向でプルリクエスト出しました
通りました
これを自主的にcloseすることはもうしません
後は向こうの裁量次第
imageの時と違って重大なバグの対応ですから
向こうが取れる手段は2つしかありません
確実にこの2つのうちいずれかが実行されます。すなわち！
・この案をマージするか
・代替案を提示してそれをマージするか
その二択です。
もうこっちしか案を出さないなどということは許されないぞ
さあ、どうする！

復活させたい気持ちはあるよ？またライブラリ作ろうって。そういう気持ち。あるけど、
モチベーションが全くわいてこないな。
やらないといけないのかな

失敗しました
他のシェーダーによりレジスタが無効化されると駄目なわけです
それで
レジスタの有効状態も考慮するように書き換えました
自分が知らなくても無効化されてる場合も有効化するということです
これでいいはず

.enabledを殺せ！！！！！
